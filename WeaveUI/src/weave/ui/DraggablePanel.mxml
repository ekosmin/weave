<?xml version="1.0" encoding="utf-8"?>
<!--
/* ***** BEGIN LICENSE BLOCK *****
 *
 * This file is part of Weave.
 *
 * The Initial Developer of Weave is the Institute for Visualization
 * and Perception Research at the University of Massachusetts Lowell.
 * Portions created by the Initial Developer are Copyright (C) 2008-2015
 * the Initial Developer. All Rights Reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/.
 * 
 * ***** END LICENSE BLOCK ***** */
-->
<mx:TitleWindow xmlns:mx="http://www.adobe.com/2006/mxml"
				xmlns:sessioning="weave.core.*"
				xmlns="weave.ui.*"
				addedToStage="handleAddedToStage(event)"
				removedFromStage="handleRemovedFromStage(event)"
				preinitialize="preinitialize()"
				rollOver="handleMouseRollOver(event)"
				rollOut="handleMouseRollOut(event)"
				horizontalScrollPolicy="off"
				verticalScrollPolicy="off"
				creationPolicy="all"
				resize="handleResize(event)"
				creationComplete="handleCreationComplete()"
				layout="absolute"
				close="handleCloseButtonClick()"
				
				closeButtonUpSkin="@Embed(source='/weave/resources/images/cancel.png')"
				closeButtonOverSkin="@Embed(source='/weave/resources/images/cancel.png')"
				closeButtonDownSkin="@Embed(source='/weave/resources/images/cancel.png')"
				
				titleStyleName="weave-panel-title-style"
				styleName="weave-panel-style"
				
				implements="weave.api.core.IDisposableObject, weave.api.core.ILinkableObject, weave.api.ui.IObjectWithDescription"
				>
	<mx:Script>
		<![CDATA[
			import mx.containers.Canvas;
			import mx.containers.DividedBox;
			import mx.controls.Alert;
			import mx.controls.Button;
			import mx.controls.ComboBox;
			import mx.controls.Image;
			import mx.core.SpriteAsset;
			import mx.core.UIComponent;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.ResizeEvent;
			import mx.managers.ISystemManager;
			import mx.managers.PopUpManager;
			
			import weave.Weave;
			import weave.api.getCallbackCollection;
			import weave.api.getLinkableOwner;
			import weave.api.newDisposableChild;
			import weave.api.newLinkableChild;
			import weave.api.objectWasDisposed;
			import weave.api.registerDisposableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.api.core.ILinkableHashMap;
			import weave.api.core.ILinkableObject;
			import weave.api.ui.ILinkableObjectEditor;
			import weave.api.ui.ISelectableAttributes;
			import weave.compiler.StandardLib;
			import weave.core.CallbackCollection;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableFunction;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.StageUtils;
			import weave.core.UIUtils;
			import weave.menus.ToolsMenu;
			import weave.menus.WeaveMenuItem;
			import weave.ui.controlBars.VisTaskbar;
			import weave.utils.CustomCursorManager;
			import weave.utils.DrawUtils;
			import weave.utils.NumberUtils;
			
			public var debug:Boolean = false;
			
			/**
			 * panelX, panelY, panelWidth, panelHeight
			 * These are sessioned strings that can be either absolute coordinates or percentages.
			 */
			public const panelX:LinkableString      = registerLinkableChild(this, new LinkableString(null, NumberUtils.verifyNumberOrPercentage));
			public const panelY:LinkableString      = registerLinkableChild(this, new LinkableString(null, NumberUtils.verifyNumberOrPercentage));
			public const panelWidth:LinkableString  = registerLinkableChild(this, new LinkableString(null, NumberUtils.verifyNumberOrPercentage));
			public const panelHeight:LinkableString = registerLinkableChild(this, new LinkableString(null, NumberUtils.verifyNumberOrPercentage));
			
			public const maximized:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false, verifyMaximized), handleMaximizedChange, true);
			public const minimized:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false, verifyMinimized), handleMinimizedChange, true);
			public const zOrder:LinkableNumber = registerLinkableChild(this, new LinkableNumber(0, StandardLib.isDefined), handleZOrderChange, true);
			
			public const panelTitle:LinkableString = newLinkableChild(this, LinkableString, handlePanelTitleChange, true);
			
			public const enableMoveResize:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			public const enableSubMenu:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false));
			public const minimizable:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			public const maximizable:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			public const enableZOrder:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			public const closeable:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			public const enableBorders:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), panelNeedsUpdate, true);
			
			public const panelBorderColor:LinkableNumber = registerLinkableChild(this, new LinkableNumber(NaN), handleBorderColorChange, true);
			public const panelBackgroundColor:LinkableNumber = registerLinkableChild(this, new LinkableNumber(NaN), handleBackgroundColorChange, true);
			public const buttonRadius:LinkableNumber = registerLinkableChild(this, new LinkableNumber(3, isFinite), panelNeedsUpdate, true);
			public const panelStyleList:LinkableString = newLinkableChild(this, LinkableString, handlePanelStyleListChange);
			
			public function set backgroundColor(value:Number):void
			{
				panelBackgroundColor.value = value;
			}
			
			private function verifyMinimized(value:Boolean):Boolean { return !minimizable || minimizable.value || !value; }
			private function verifyMaximized(value:Boolean):Boolean { return !maximizable || maximizable.value || !value; }
			
			public const userControlButton:Button = new Button();
			public const subMenuButton:MenuButton = new MenuButton();
			public const attributeButton:Button = new Button();
			public const toggleButton:Button = new Button();
			protected const minimizeButton:Button = new Button();
			protected const maximizeButton:Button = new Button();
			protected const closePanelButton:Button = new Button();
			protected const zOrderButton:MenuButton = new MenuButton();
			
			private const _dragCanvas:Canvas = new Canvas();
			
			/**
			 * Set this to false to avoid creating a busy indicator. Must be set before creationComplete.
			 */
			public var showBusyIndicator:Boolean = true;
			
			private var busyIndicator:BusyIndicator;
			
			private var _moveImage:Image = new Image();

			private var _constructorCalled:Boolean = false; // true when constructor has been called
			private const panelTitleFunction:LinkableFunction = registerDisposableChild(this, new LinkableFunction(null, true, true)); // this is used in handlePanelTitleChange()
			
			[Bindable] public var enablePercentageCoords:Boolean = true;
			
			private var _overriddenStyles:Object = new Object();
			private var draggablePanelCursorID:int = -1;
			
			private var _escapeKeyClosesPanel:Boolean = false;
			private var _initialTitleBarMouseDownPoint:Point = new Point(0,0);
			
			private var _rightSideResize:Boolean = false;
			private var _leftSideResize:Boolean = false;
			private var _topSideResize:Boolean = false;
			private var _bottomResize:Boolean = false;
			private var _resizing:Boolean = false;
			private var _dragging:Boolean = false;
			
			private var _enableMoveResize:Boolean = false; // used internally to remember whether or not the panel is actually moveable
			
			private var _rightSideBeforeLeftResize:int = 0;
			private var _bottomSideBeforeTopResize:int = 0;
			
			private var _mouseRolledOver:Boolean = false;
			private var _controlPanel:ControlPanel = null;
			private var _editorFactory:IFactory = null;
			private var buttonSize:int = 17;
			private var buttonOffsetFromSide:int = 5;
			private var spaceBetweenButtons:Number = 2;
			private var _titleBarButtonBackgroundColor:uint = 0xD0D0D0;
			private var _titleBarButtonSelectedColor:uint   = 0xFFFF80;
			private var minimizedComponentVersion:MinimizedComponent = null;
			
			public function get controlPanel():ControlPanel
			{
				return _controlPanel;
			}
			public function set editorFactory(factory:IFactory):void
			{
				_editorFactory = factory;
			}

			/**
			 *  This method is called when a UIComponent is constructed,
			 *  and again whenever the ResourceManager dispatches
			 *  a <code>"change"</code> Event to indicate
			 *  that the localized resources have changed in some way.
			 */
			override protected function resourcesChanged():void
			{
				super.resourcesChanged();
				if (!_constructorCalled) // avoid calling constructor twice
				{
					_constructorCalled = true;
					reposition();
					inConstructor();
				}
			}
			
			/**
			 * A constructor cannot be defined in MXML.
			 * This function gets called as a result of calling the super class's constructor.
			 * Classes that extend DraggablePanel can override this and call super.inConstructor().
			 * Any code that should execute in the constructor can be put into this function.
			 * This function should not be called directly.
			 */
			protected function inConstructor():void
			{
				// use capture phase on mouse down event because otherwise, if the panel is a popup,
				// drop-down menus will be hidden behind the window after we move the window to the front.
				addEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown, true);
				
				panelX.addImmediateCallback(this, function():void { copyCoordinatesFromSessionedProperties(panelX); });
				panelY.addImmediateCallback(this, function():void { copyCoordinatesFromSessionedProperties(panelY); });
				panelWidth.addImmediateCallback(this, function():void { copyCoordinatesFromSessionedProperties(panelWidth); });
				panelHeight.addImmediateCallback(this, function():void { copyCoordinatesFromSessionedProperties(panelHeight); });
				
				registerLinkableChild(panelBackgroundColor, Weave.properties.panelBackgroundColor);
				getCallbackCollection(Weave.properties.panelTitleTextFormat).addGroupedCallback(this, handleTitleTextFormatChange, true);
				Weave.properties.dashboardMode.addGroupedCallback(this, panelNeedsUpdate);
				Weave.properties.enableToolControls.addGroupedCallback(this, updateButtons, true);
				getCallbackCollection(this).addGroupedCallback(this, updateButtonsIfSelectableAttributesChanged, true);
				getCallbackCollection(this).addGroupedCallback(this, evaluatePanelTitle);
				getCallbackCollection(Weave.root).addGroupedCallback(this, evaluatePanelTitle);
			}
			
			/**
			 * This function gets called when the preinitialize event is dispatched.
			 * Subclasses can override this method and call super.preinitialize().
			 */
			protected function preinitialize():void
			{
				// nothing here, just a placeholder
			}
			
			protected var createdChildren:Boolean = false;
			override protected function createChildren():void
			{
				if (createdChildren)
					return;
				
				super.createChildren();
				
				createdChildren = true;
				
				// These calls to setStyle fix the display bug where there is a ~200 px bottom margin and ~20 px right margin.
				UIUtils.pad(this, 0);
				
				setupControlButton(userControlButton, [_userControlIcon, _userControlIcon2, _userControlIcon], toggleControlPanel, TOOLTIP_CONTROLS);
				setupControlButton(subMenuButton, null, null, TOOLTIP_SUBMENU);
				setupControlButton(attributeButton, _attributeIcon, handleAttributeButtonClick, TOOLTIP_ATTRIBUTES);
				setupControlButton(toggleButton, _attributeIcon, handleToggleButtonClick, TOOLTIP_TOGGLE);
				setupControlButton(zOrderButton, [icon_zOrder, icon_zOrderReverse, icon_zOrder], null);
				setupControlButton(minimizeButton, _minimizeIcon, handleMinimizeButtonClick, TOOLTIP_MINIMIZE);
				setupControlButton(maximizeButton, _maximizeIcon, toggleMaximized, TOOLTIP_MAXIMIZE);
				setupControlButton(closePanelButton, [_closeIcon, _closeIconColor2, _closeIconColor], handleCloseButtonClick, TOOLTIP_CLOSE);
				
				subMenuButton.smallIcon = true;
				zOrderButton.data = [
					{
						label: lang('Always above'),
						click: function():void { zOrder.value = 1; },
						type: WeaveMenuItem.TYPE_RADIO,
						toggled: function():Boolean { return zOrder.value > 0; }
					},{
						label: lang('Always below'),
						click: function():void { zOrder.value = -1; },
						type: WeaveMenuItem.TYPE_RADIO,
						toggled: function():Boolean { return zOrder.value < 0; }
					},{
						label: lang('Reset'),
						click: function():void { zOrder.value = 0; },
						shown: function():Boolean { return zOrder.value != 0; }
					}
				];
				
				var hashMap:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
				if (hashMap)
					hashMap.childListCallbacks.addGroupedCallback(this, updatePanelZOrder);

				/*
				closePanelButton.setStyle("textRollOverColor", 0xFFFFFF);
				closePanelButton.setStyle("textSelectedColor", 0xFFFFFF);
				
				closePanelButton.addEventListener(MouseEvent.ROLL_OVER, function(e:Event):void {
					// make the close button red with white text when rolled over
					closePanelButton.setStyle("fillColors", [0xFF0000,0xFF0000] );
				});
				closePanelButton.addEventListener(MouseEvent.ROLL_OUT,  function(e:Event):void {
					// make the close button gray with black text when rolled out (default)
					closePanelButton.setStyle("fillColors", [_titleBarButtonBackgroundColor,_titleBarButtonBackgroundColor] );
				});
				*/
				
				// try to find a ControlPanel
				for (var i:int = 0; i < numChildren; i++)
				{
					if (getChildAt(i) is ControlPanel)
					{
						trace(StandardLib.substitute("Warning ({0}): Defining a ControlPanel as a child slows startup. Instead, use the editorFactory setter in DraggablePanel.", getQualifiedClassName(this).split("::").pop()));
						_controlPanel = registerDisposableChild(this, getChildAt(i) as ControlPanel);
						removeChild(_controlPanel);
						break;
					}
				}
				
				var icon:Bitmap = new MoveIcon() as Bitmap;
				_moveImage.toolTip = lang(TOOLTIP_MOVE);
				_moveImage.source = icon;
				_moveImage.x = resizeBorderThickness;
				_moveImage.y = resizeBorderThickness;
				_moveImage.width = icon.width;
				_moveImage.height = icon.height;
				_moveImage.scaleContent = false;
				_moveImage.alpha = 0.25;
				_moveImage.addEventListener(MouseEvent.MOUSE_DOWN, handleTitleBarMouseDown);
				_moveImage.doubleClickEnabled = true;
				_moveImage.addEventListener(MouseEvent.DOUBLE_CLICK, function(e:Event):void { toggleControlPanel(); });
				
				var moveImageSubMenu:SubMenu = new SubMenu(_moveImage, function():Array {
					return WeaveMenuItem.createItems([
						enableSubMenu.value ? subMenuButton.menu.getMenuItems() : null,
						{label: lang(TOOLTIP_CONTROLS), shown: shouldShowUserControlButton, click: toggleControlPanel},
						{label: lang(TOOLTIP_ATTRIBUTES), shown: shouldShowAttributeButton, click: handleAttributeButtonClick},
						{label: lang(TOOLTIP_TOGGLE), shown: shouldShowAttributeButton, click: handleToggleButtonClick},
						WeaveMenuItem.TYPE_SEPARATOR,
						{label: lang(TOOLTIP_ZORDER_MENU), shown: enableZOrder, children: zOrderButton.menu.getMenuItems},
						{label: lang(TOOLTIP_MINIMIZE), shown: minimizable, click: minimized},
						{label: maximizeButton.toolTip, shown: maximizable, click: maximized},
						{label: lang(TOOLTIP_CLOSE), shown: closeable, click: removePanel}
					]);
				});
				moveImageSubMenu.setSubMenuEvents([], [MouseEvent.MOUSE_DOWN, Event.REMOVED_FROM_STAGE]);
				StageUtils.addPointClickListener(_moveImage, function(event:Event):void { moveImageSubMenu.showSubMenu(); });
				_moveImage.data = moveImageSubMenu;
				
				
				
				titleBar.doubleClickEnabled = true;
				titleBar.addEventListener(MouseEvent.MOUSE_DOWN, handleTitleBarMouseDown);
				titleBar.addEventListener(MouseEvent.DOUBLE_CLICK, handleTitleBarDoubleClick);
				
				minWidth = 24;
				
				addEventListener(DragEvent.DRAG_ENTER, handleDragEnter, true);
				addEventListener(DragEvent.DRAG_ENTER, handleDragEnter);
				
				handleTitleTextFormatChange();
				panelNeedsUpdate();
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				panelNeedsUpdate();
				
				if (panelTitle.triggerCounter == CallbackCollection.DEFAULT_TRIGGER_COUNT)
					panelTitle.triggerCallbacks(); // force defaultPanelTitle to be used
			}
			
			private function handleCreationComplete():void
			{
				//_dragCanvas.percentWidth = 100;
				//_dragCanvas.percentHeight = 100;
				rawChildren.addChild(_dragCanvas);
				rawChildren.addChild(_moveImage);
				
				if (showBusyIndicator)
				{
					busyIndicator = new BusyIndicator(this as ILinkableObject);
					rawChildren.addChild(busyIndicator);
				}
			}
			
			/**
			 * Put code here to run when the user creates a new instance of this panel from a menu.
			 */
			public function onUserCreation():void
			{
				callLater(ToolsMenu.handleDraggablePanelAdded, [this]);
			}
			
			/**
			 * Put code here to run when the user closes the panel.
			 */
			public function onUserClose():void
			{
				
			}
			
			public function getDescription():String
			{
				return title;
			}
			
			/**
			 * Override this function to provide a default panel title when the panelTitle session state is undefined.
			 * The panel title will be set when handlePanelTitleChange() is called.
			 * If you need the panel title to be updated, you can call handlePanelTitleChange() directly or as a callback.
			 */
			public function get defaultPanelTitle():String
			{
				return _defaultTitle || lang(getQualifiedClassName(this).split(':').pop());
			}
			
			// workaround to fix text layout performance problem
			override public function set title(value:String):void
			{
				if (panelTitle.triggerCounter == CallbackCollection.DEFAULT_TRIGGER_COUNT)
					_defaultTitle = value;
				super.title = value && value.substr(0, 256);
			}
			internal var _defaultTitle:String;
			
			/**
			 * This gets called when the panelTitle session state changes.
			 * If you need the panel title to be updated, you can call this function directly or as a callback.
			 * If you need to override the default panel title, override the "get defaultPanelTitle" accessor function.
			 */
			protected function handlePanelTitleChange():void
			{
				if (panelTitle.value)
				{
					panelTitleFunction.value = '`' + panelTitle.value.split('`').join('\\`') + '`';
					// title will be automatically updated by grouped callback
				}
				else
				{
					title = defaultPanelTitle;
				}
			}
			
			// this gets called as a grouped callback when Weave.root changes and whenever panelTitle can be compiled to a function
			private function evaluatePanelTitle():void
			{
				try
				{
					if (panelTitle.value)
						title = panelTitleFunction.apply(this);
				}
				catch (e:Error)
				{
					//reportError(e);
					title = panelTitle.value;
				}
			}
			
			private function handleTitleTextFormatChange():void
			{
				if (!parent)
				{
					callLater(handleTitleTextFormatChange);
					return;
				}
				Weave.properties.panelTitleTextFormat.copyToStyle(titleBar);
				titleTextField.setColor(Weave.properties.panelTitleTextFormat.color.value);
			}
			
			// this metadata tag allows you to specify a percentage value like x="25%" in MXML.
			[PercentProxy("percentX")]
			override public function set x(value:Number):void
			{
				value = Math.round(value);
				super.x = value;
			}
			// this metadata tag allows you to specify a percentage value like y="25%" in MXML.
			[PercentProxy("percentY")]
			override public function set y(value:Number):void
			{
				value = Math.round(value);
				super.y = value;
			}
			
//			[PercentProxy("percentWidth")]
//			override public function set width(value:Number):void
//			{
//				super.width = Math.round(value);
//			}
//			[PercentProxy("percentHeight")]
//			override public function set height(value:Number):void
//			{
//				super.height = Math.round(value);
//			}
			
			[Inspectable(environment="none")]
			public function set percentX(value:Number):void
			{
				panelX.value = "" + value + "%";
			}
			[Inspectable(environment="none")]
			public function set percentY(value:Number):void
			{
				panelY.value = "" + value + "%";
			}
			
			override public function set percentWidth(value:Number):void
			{
				if (parent is DividedBox)
					super.percentWidth = value;
				else
					panelWidth.value = "" + value + "%";
			}
			override public function set percentHeight(value:Number):void
			{
				if (parent is DividedBox)
					super.percentHeight = value;
				else
					panelHeight.value = "" + value + "%";
			}
			
			private function handlePanelStyleListChange():void
			{
				_overriddenStyles = new Object();
				
				try
				{
					var ss:StyleSheet = new StyleSheet();
					var styleName:String = 'panel';
					ss.parseCSS(styleName + '{' + panelStyleList.value + '}');
					var style:Object = ss.getStyle(styleName);
					for (var propName:String in style)
					{
						var value:* = style[propName];
						
						// the only case that seems to cause problems is Numbers, which will not get parsed properly when 
						// in String format by getStyle(...).  If it is a valid Number, cast it to one
						try {
							_overriddenStyles[propName] = Number(value);
						} catch (e:Error) { } // ok if number parse fails
						
						if (isNaN(_overriddenStyles[propName]))
							_overriddenStyles[propName] = String(value);
					}
				}
				catch(error:Error) { } // ok if style parse fails
				
				// notify style change, just a random style chosen here so we only call it once instead of in the loop above
				// this causes the style changes above to take effect
				styleChanged("headerHeight");
				notifyStyleChangeInChildren("headerHeight", true);
			}
			
			private function handleAddedToStage(event:Event):void
			{
				WeaveAPI.StageUtils.addEventCallback(StageUtils.THROTTLED_MOUSE_MOVE_EVENT, this, handleThrottledMouseMove);
				stage.addEventListener(MouseEvent.MOUSE_MOVE, handleStageMouseMove);
				stage.addEventListener(MouseEvent.MOUSE_UP, handleStageMouseUp);
				parent.addEventListener(ResizeEvent.RESIZE, handleParentResize);
				
				copyCoordinatesFromSessionedProperties();
			}
			private function handleRemovedFromStage(event:Event):void
			{
				WeaveAPI.StageUtils.removeEventCallback(StageUtils.THROTTLED_MOUSE_MOVE_EVENT, handleThrottledMouseMove);
				stage.removeEventListener(MouseEvent.MOUSE_MOVE, handleStageMouseMove);
				stage.removeEventListener(MouseEvent.MOUSE_UP, handleStageMouseUp);
				parent.removeEventListener(ResizeEvent.RESIZE, handleParentResize);
				if (!maximized.wasDisposed)
					maximized.triggerCallbacks();
			}
			
			
			/**
			 * This function copies the values for x,y,width,height from the corresponding sessioned properties.
			 * @param singleProperty Set this to one of panelX,panelY,panelWidth,panelHeight to only update that property.
			 */
			internal function copyCoordinatesFromSessionedProperties(singleProperty:LinkableString = null):void
			{
				if (!parent)
					return;
				if (!singleProperty || singleProperty == panelX)
					copyCoordinateFromLinkableString(panelX, parent.width, "x");
				if (!singleProperty || singleProperty == panelY)
					copyCoordinateFromLinkableString(panelY, parent.height, "y");
				if (!singleProperty || singleProperty == panelWidth)
					copyCoordinateFromLinkableString(panelWidth, parent.width, "width", minWidth);
				if (!singleProperty || singleProperty == panelHeight)
					copyCoordinateFromLinkableString(panelHeight, parent.height, "height", minHeight);
				callLater(fixHeight);
			}
			private function fixHeight():void
			{
				if (!parent)
					return;
				if (y + height > parent.height) // rounding error, reproduceable when parent height is 625
					height = parent.height - y;
			}
			
			/**
			 * This function will copy a sessioned string like "75%" as a Number using the calculation "part = whole * percent / 100".
			 * If the sessioned string does not have a "%" sign in it, it will be treated as an absolute coordinate.
			 * @param part The LinkableString contianing the "part" value to use in the calculation.
			 * @param whole The "whole" value in the calculation (parent width or height).
			 * @param destinationPropertyName The name of a property to set on this object (x, y, width, or height) which is the "part" value.
			 */
			private function copyCoordinateFromLinkableString(part:LinkableString, whole:Number, destinationPropertyName:String, minValue:Number = NaN):void
			{
				if (!parent)
					return;
				
				var numberOrPercent:String = part.value;
				
				// if maximized, use maximized coordinates
				if (isMaximized)
					numberOrPercent = _maximizedCoordinates[destinationPropertyName];
				
				var result:Number = NumberUtils.getNumberFromNumberOrPercent(numberOrPercent, whole);
				
				//trace("handleAbsoluteAndPercentageValues",arguments,numberOrPercent,whole,result);
				if (isFinite(result))
				{
					if (isFinite(minValue))
						result = Math.max(minValue, result);
					this[destinationPropertyName] = result;
				}
			}
			
			private function panelNeedsUpdate():void
			{
				if (!parent)
					return;
				
				// disable highlight when borders are disabled (avoids display bug when corners are rounded)
				setStyle('highlightAlphas', enableBorders.value ? undefined : [0,0]);
				
				_enableMoveResize = (!Weave.properties.dashboardMode.value && enableMoveResize.value) || adminMode;
				if (!enableMoveResize.value && _enableMoveResize)
					_moveImage.alpha = 0.1;
				else
					_moveImage.alpha = 0.25;
				
				if (!maximizable.value)
					maximized.value = false;
				if (!minimizable.value)
					minimized.value = false;
				if (!enableZOrder.value)
					zOrder.value = 0;
				
				invalidateSize();
				invalidateDisplayList();
				updateBorders();
			}
			
			override public function move(x:Number, y:Number):void
			{
				super.move(Math.round(x), Math.round(y));
			}
			
			/**
			 * This function constrains x,y,width,height so that this DraggablePanel is contained in its parent,
			 * then it saves the coordinates (absolute or percentage) to the sessioned properties.
			 */
			protected function constrainAndSaveCoordinates():void
			{
				// keep left side of panel on screen
				if (x + minWidth > parent.width)
					x = parent.width - minWidth;
				// keep top of panel on screen
				if (y + minHeight > parent.height)
					y = parent.height - minHeight;
				// keep right side of panel on screen
				if (x + width < minWidth)
					x = minWidth - width;
				// keep titlebar on screen
				if (y < 0)
					y = 0;
				
				// don't copy coordinates while tool is minimized or maximized
				if (!parent || minimized.value || isMaximized || parent is ISystemManager)
					return;
				
				// init local vars
				var _x:Number = x;
				var _y:Number = y;
				var _right:Number = x + width;
				var _bottom:Number = y + height;
				var _parentWidth:Number = parent.width;
				var _parentHeight:Number = parent.height;
				
				// calculate snap size
				var snapStr:String = Weave.properties.windowSnapGridSize.value;
				var snapToPercent:Boolean = snapStr.indexOf('%') >= 0;
				var usePercent:Boolean = enablePercentageCoords && snapToPercent;
				var snapNum:Number = StandardLib.asNumber(snapStr.replace('%', ''));
				
				// adjust snap to match panel coordinate mode
				if (usePercent != snapToPercent)
				{
					if (usePercent)
						snapNum = 100 * snapNum / Math.max(_parentWidth, _parentHeight);
					else
						snapNum = Math.round(Math.max(_parentWidth, _parentHeight) * snapNum / 100)
				}
				if ((usePercent && snapNum <= 0) || (!usePercent && snapNum < 1))
					snapNum = 1;
				
				// convert numbers to percentages if necessary
				if (usePercent)
				{
					_x = 100 * _x / _parentWidth;
					_y = 100 * _y / _parentHeight;
					_right = 100 * _right / _parentWidth;
					_bottom = 100 * _bottom / _parentHeight;
					_parentWidth = 100;
					_parentHeight = 100;
				}
				// truncate width,height
				_parentWidth = Math.floor(_parentWidth / snapNum) * snapNum;
				_parentHeight = Math.floor(_parentHeight / snapNum) * snapNum;
				
				// snap coordinates to grid
				_x = Math.round(_x / snapNum) * snapNum;
				_y = Math.round(_y / snapNum) * snapNum;
				var _width:Number = Math.round(_right / snapNum) * snapNum - _x;
				var _height:Number = Math.round(_bottom / snapNum) * snapNum - _y;
				
				// constrain width,height before x,y because the x,y constrain code depends on width,height
				_width = Math.round(StandardLib.constrain(_width, 0, _parentWidth));
				_height = Math.round(StandardLib.constrain(_height, 0, _parentHeight));
				_x = Math.round(StandardLib.constrain(_x, 0, _parentWidth - _width));
				_y = Math.round(StandardLib.constrain(_y, 0, _parentHeight - _height));
				
				// copy the x,y,width,height coordinates to the corresponding sessioned properties.
				var str:String = usePercent ? '%' : '';
				panelWidth.value = _width + str;
				panelHeight.value = _height + str;
				panelX.value = _x + str;
				panelY.value = _y + str;
				copyCoordinatesFromSessionedProperties();
			}
			
			private function handleResize(event:ResizeEvent):void
			{
				if (!parent)
					return;
				
				if (_dragging || _resizing)
					constrainAndSaveCoordinates();
			}
			
			protected function updateBorders():void
			{
				if (!parent)
					return;
				
				styleChanged("headerHeight");
				notifyStyleChangeInChildren("headerHeight", true);
				updateMoveIcon();
				invalidateDisplayList();
			}
			
			private function updateMoveIcon():void
			{
				//the moveImage will be enabled if the enableMoveIcon is enabled and the panel is moveable and headerHeight is zero.
				_moveImage.visible = _enableMoveResize && !borderIsVisible && (adminMode || !Weave.properties.dashboardMode.value);
			}
			
			protected function get borderIsVisible():Boolean
			{
				if (objectWasDisposed(this))
					return false;
				return enableBorders.value && (parent is ISystemManager || !Weave.properties.dashboardMode.value);
			}
			
			override public function styleChanged(styleProp:String):void
			{
				if (styleProp == 'backgroundColor')
					panelBackgroundColor.setSessionState(super.getStyle('backgroundColor'));
				super.styleChanged(styleProp);
			}
			
			override public function getStyle(styleProp:String):*
			{
				var value:* = null;	
				
				// if we override the borders before the window has been intialized, tools display nothing
				if (initialized)
				{
					// if we are hiding the borders, return style bogus values that cause the borders to hide
					if (!borderIsVisible)
					{
						// override border styles to hide the borders
						
						var borderProps:Array = [
							"borderThicknessTop",
							"borderThicknessBottom",
							"borderThicknessLeft",
							"borderThicknessRight",
							"headerHeight",
							"cornerRadius"
						];
						if (borderProps.indexOf(styleProp) >= 0)
							return 0;
						
						if (styleProp == "dropShadowEnabled")
							return false;
					}
				}
				
				if (_overriddenStyles[styleProp] != undefined )
					value = _overriddenStyles[styleProp];
				else if (styleProp == 'backgroundColor')
				{
					if (isFinite(panelBackgroundColor.value))
						value = panelBackgroundColor.value;
					else
						value = Weave.properties.panelBackgroundColor.value;
				}
				else if (styleProp == 'borderColor' && isFinite(panelBorderColor.value))
					value = panelBorderColor.value;
				else
					value = super.getStyle(styleProp);
				
				// make sure the headerHeight is at least the size of the cornerRadius,
				// otherwise the stuff inside the panel sticks outside the panel
				if (styleProp == "headerHeight")
					return Math.max(getStyle("cornerRadius"), value );
				
				return value;
			}
			
			/**
			 * The parameter to this function is a generic Event to avoid crashing when parent is systemManager.
			 * If we make the type ResizeEvent, we may get the error "Cannot convert Event to ResizeEvent".
			 */
			private function handleParentResize(event:Event):void
			{
				if (enablePercentageCoords)
				{
					var snapStr:String = Weave.properties.windowSnapGridSize.value;
					if (snapStr && snapStr.indexOf("%") >= 0)
						copyCoordinatesFromSessionedProperties();
				}
			}
			
			private function handleZOrderChange():void
			{
				if (zOrder.value == 0)
				{
					zOrderButton.toolTip = lang(TOOLTIP_ZORDER);
					setupButtonIcons(zOrderButton, [icon_zOrder, icon_zOrderReverse, icon_zOrder]);
					zOrderButton.setStyle("fillColors", [_titleBarButtonBackgroundColor, _titleBarButtonBackgroundColor]);
				}
				else
				{
					if (zOrder.value < 0)
					{
						zOrderButton.toolTip = lang("Always below");
						setupButtonIcons(zOrderButton, [icon_zOrderBelow, icon_zOrderBelow_color, icon_zOrderBelow_color]);
					}
					else
					{
						zOrderButton.toolTip = lang("Always above");
						setupButtonIcons(zOrderButton, [icon_zOrderAbove, icon_zOrderAbove_color, icon_zOrderAbove_color]);
					}
					zOrderButton.setStyle("fillColors", [_titleBarButtonSelectedColor, _titleBarButtonSelectedColor]);
				}
				updatePanelZOrder();
			}
			
			public function toggleMaximized():void
			{
				// toggle maximized state
				maximized.value = !maximized.value;
			}
			
			private function handleMaximizedChange():void
			{
				copyCoordinatesFromSessionedProperties();
				
				setupButtonIcons(maximizeButton, maximized.value ? _unmaximizeIcon : _maximizeIcon);
				maximizeButton.toolTip = maximized.value ? lang(TOOLTIP_RESTORE) : lang(TOOLTIP_MAXIMIZE);
			}
			
			private function handleBorderColorChange():void
			{
				updateBorders();
			}
			
			private function handleBackgroundColorChange():void
			{
				updateBorders();
			}
			private function handleCloseButtonClick():void
			{
				if (Weave.properties.showVisToolCloseDialog.value)
				{
					Alert.show("Are you sure you want to close this window?", "Closing this window...", 1|2, this, handleCloseAlertResult);
					function handleCloseAlertResult(event:CloseEvent):void
					{			
						if (event.detail == Alert.YES)
						{
							onUserClose();
							removePanel();
						}
					}
				}
				else
				{
					onUserClose();
					removePanel();
				}
			}
			
			public function removePanel():void
			{
				var owner:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
				if (owner && owner.getName(this))
				{
					owner.removeObject(owner.getName(this));
					return;
				}
				
				var panels:Array = [this, _controlPanel];
				DraggablePanel.activePanel = null;
				for each (var panel:DraggablePanel in panels)
				{
					if (!panel)
						continue;
					try
					{
						// un-maximize
						panel.maximized.value = false;
						if (panel && panel.parent)
							UIUtils.spark_removeChild(panel.parent, panel);
					}
					catch (e:Error)
					{
						reportError(e);
					}
				}
			}
			
			private function handleMouseDown(event:MouseEvent):void
			{
				var o:DisplayObject = event.target as DisplayObject;
				while (o)
				{
					// stop when clicking on a combo box
					if (o is ComboBox)
						return;
					o = o.parent;
				}
				
				if (!_enableMoveResize)
					return;
				
				if (!parent)
					return;
				
				_leftSideResize = false;
				_rightSideResize = false;
				_topSideResize = false;
				_bottomResize = false;
				
				
				// bring panel to front
				if (parent.getChildIndex(this) < parent.numChildren-1)
					sendWindowToForeground();
				
				
				if (!minimized.value && !isMaximized)
				{
					var status:Object = getResizeStatus(stage.mouseX, stage.mouseY);
					
					if (status.R)
						_rightSideResize = true;
					else if (status.L)
					{
						_rightSideBeforeLeftResize = this.x + this.width;
						_leftSideResize = true;
					}
					
					
					if (status.B)
						_bottomResize = true;
					else if (status.T)
					{
						_bottomSideBeforeTopResize = this.y + this.height;
						_topSideResize = true;
					}
					
					if (getResizeStatus(stage.mouseX, stage.mouseY).resizing)
					{
						_resizing = true;
						event.stopImmediatePropagation();
					}
					else
						_resizing = false;
				}
			}
			
			/**
			 * getResizeStatus
			 * Returns a set of Boolean values corresponding to which sides (top,left,bottom,right) should be resized.
			 * @param stageX The current stage X mouse coordinate.
			 * @param stageY The current stage Y mouse coordinate.
			 * @return An object containing the following properties: T,L,B,R,TL,TR,BL,BR,resizing
			 */
			private function getResizeStatus(stageX:Number, stageY:Number):Object
			{
				var local:Point = globalToLocal(new Point(stageX, stageY));
				var o:Object = new Object();
				
				// get side status values
				o.L = local.x <= resizeBorderThickness;
				o.R = local.x >= this.width - resizeBorderThickness;
				o.T = local.y <= resizeBorderThickness;
				o.B = local.y >= this.height - resizeBorderThickness;
				
				// get side status values for 4x the border thickness (to mimic Windows' corner resize behavior)
				var L4:Boolean = local.x <= resizeBorderThickness * 4;
				var R4:Boolean = local.x >= this.width - resizeBorderThickness * 4;
				var T4:Boolean = local.y <= resizeBorderThickness * 4;
				var B4:Boolean = local.y >= this.height - resizeBorderThickness * 4;
				// corner status is true if mouse is within a square of 4x the border thickness and at least one corresponding side status is true
				o.TL = (T4 && L4) && (o.T || o.L);
				o.TR = (T4 && R4) && (o.T || o.R);
				o.BL = (B4 && L4) && (o.B || o.L);
				o.BR = (B4 && R4) && (o.B || o.R);
				// status for individual sides should be or'd with relevant corner status values
				o.T |= o.TL || o.TR;
				o.L |= o.TL || o.BL;
				o.B |= o.BL || o.BR;
				o.R |= o.TR || o.BR;
				
				// not resizing when coordinates are outside the window
				if (!_mouseRolledOver)
					o.T = o.TL = o.L = o.BL = o.B = o.BR = o.R = o.TR = false;
				
				// we are resizing if we are in the resize area for the top, left, bottom or right
				o.resizing = (o.T || o.L || o.B || o.R);
				
				return o;
			}
			
			// Keep track of the active panel (one that the user has their mouse over) for use in exporting a panel image in the context menu.
			// This is needed so that when the user right clicks on a panel, we know which panel they want to export an image of (cannot tell
			// it from the context menu event).  
			private function handleMouseRollOver(event:MouseEvent):void
			{
				_mouseRolledOver = true;
				DraggablePanel.activePanel = this;
				
				if (_resizing)
					event.stopImmediatePropagation();
			}
			private function handleMouseRollOut(event:MouseEvent):void
			{
				_mouseRolledOver = false;
				DraggablePanel.activePanel = null;
				
				if (_resizing)
					event.stopImmediatePropagation();
				else
					CustomCursorManager.removeCursor(draggablePanelCursorID);
			}
			
			private function get isMaximized():Boolean
			{
				return maximized.value || parent is DividedBox;
			}
			
			public function sendWindowToForeground():void
			{
				if (_enableMoveResize)
				{
					// put the name of this panel at the end of the hash map names so it appears in front
					var hashMap:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
					if (hashMap)
						hashMap.setNameOrder([hashMap.getName(this)]);
					else if (parent)
						parent.setChildIndex(this, parent.numChildren - 1);
				}
				updatePanelZOrder();
			}
			
			public function sendWindowToBackground():void
			{
				if (_enableMoveResize)
				{
					// put the name of this panel at the beginning of the hash map names so it appears in back
					var hashMap:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
					if (hashMap)
					{
						var names:Array = hashMap.getNames();
						names.unshift(hashMap.getName(this));
						hashMap.setNameOrder(names);
					}
				}
				updatePanelZOrder();
			}
			
			private function updatePanelZOrder():void
			{
				var hashMap:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
				if (hashMap)
				{
					var names:Array = hashMap.getNames();
					var back:Array = [];
					var front:Array = [];
					for (var i:int = 0; i < names.length; i++)
					{
						var name:String = names[i];
						var panel:DraggablePanel = hashMap.getObject(name) as DraggablePanel;
						if (panel)
						{
							if (panel.zOrder.value > 0)
							{
								front.push(name);
								names.splice(i--, 1);
							}
							else if (panel.zOrder.value < 0)
							{
								back.push(name);
								names.splice(i--, 1);
							}
						}
					}
					hashMap.setNameOrder(back.concat(names).concat(front));
				}
			}
			
			private function handleTitleBarDoubleClick(event:MouseEvent):void
			{
				// do not allow double click on any of the control buttons
				if (event.target is Button)
					return;
				
				toggleMaximized();
			}
			private function handleTitleBarMouseDown(event:MouseEvent):void
			{
				if (!_enableMoveResize || isMaximized)
					return;
				
				if (!parent)
					return;
				
				sendWindowToForeground();
				
				_initialTitleBarMouseDownPoint = globalToLocal(new Point(stage.mouseX, stage.mouseY));
				
				if (getResizeStatus(stage.mouseX, stage.mouseY).resizing)
					_dragging = false;
				else
					_dragging = true;
				
				
				// we don't want to allow resizing or dragging if we are on any of the buttons
				if (event.target is Button || event.target is SpriteAsset)
				{
					_dragging = false;
					_resizing = false;
				}
			}
			
			private function handleStageMouseUp(event:MouseEvent):void
			{
				_dragging = false;
				_resizing = false;
				_leftSideResize = false;
				_rightSideResize = false;
				_topSideResize = false;
				_bottomResize = false;
			}
			private function handleStageMouseMove(event:MouseEvent):void
			{
				// make sure cursors dont keep changing while resizing:  !_resizing
				if (parent && !_resizing && !minimized.value && !isMaximized)
				{
					var status:Object = getResizeStatus(stage.mouseX, stage.mouseY);
					var resizeCursorName:String = null;
					// check to see if the mouse is in the top left (TL) or bottom right (BR) corner
					if (status.TL || status.BR)
						resizeCursorName = CURSOR_RESIZE_TOPLEFT_BOTTOMRIGHT;
						// check to see if the mouse is in the top right (TR) or bottom left (BL) corner
					else if (status.TR || status.BL)
						resizeCursorName = CURSOR_RESIZE_TOPRIGHT_BOTTOMLEFT;
						// check to see if the mouse is on the left or right side (LR)
					else if (status.L || status.R)
						resizeCursorName = CURSOR_RESIZE_LEFT_RIGHT;
						// check to see if the mouse is on the top or bottom side
					else if (status.T || status.B)
						resizeCursorName = CURSOR_RESIZE_TOP_BOTTOM;
					
					CustomCursorManager.removeCursor(draggablePanelCursorID);
					if ( resizeCursorName!= null && !event.buttonDown && _enableMoveResize)
					{
						if (debug)
							weaveTrace(debugId(this), resizeCursorName, debugId(event), debugId(event.target));
						
						try
						{
							draggablePanelCursorID = CustomCursorManager.showCursor(resizeCursorName);
						}
						catch (e:Error)
						{
							draggablePanelCursorID = -1;
							reportError(e);
						}
					}
				}
				
				if (_dragging || _resizing)
					event.stopImmediatePropagation();
				
				handleThrottledMouseMove();
			}
			
			private function handleThrottledMouseMove():void
			{
				// don't do anything if this panel is not added to the stage.
				if (!parent)
					return;
				
				if (!_enableMoveResize)
					return;
				
				var parentMousePoint:Point = new Point(parent.mouseX, parent.mouseY);
				
				if (_dragging)
				{
					// constrain the window X location to be between 0 and the right side of the window
					var newX:int = parentMousePoint.x - _initialTitleBarMouseDownPoint.x;
					// constrain the window Y location to be between 0 and the bottom of the window
					var newY:int = parentMousePoint.y - _initialTitleBarMouseDownPoint.y;
					this.move(newX, newY);
					constrainAndSaveCoordinates();
				}
				if (_resizing)
				{
					if (_rightSideResize)
					{
						this.width = StandardLib.constrain( (parentMousePoint.x - this.x), minWidth, (parent.width - this.x) );
					}
					else if (_leftSideResize)
					{
						this.x = StandardLib.constrain( (parentMousePoint.x), 0, _rightSideBeforeLeftResize - minWidth );
						this.width = (_rightSideBeforeLeftResize - this.x);
					}
					if (_bottomResize)
					{
						this.height = StandardLib.constrain( (parentMousePoint.y - this.y), minHeight, (parent.height - this.y) );
					}
					else if (_topSideResize)
					{
						this.y = StandardLib.constrain( (parentMousePoint.y), 0, _bottomSideBeforeTopResize - minHeight );
						this.height = (_bottomSideBeforeTopResize - this.y);
					}
					constrainAndSaveCoordinates();
				}
			}
			
			protected var _controlPanelInitialized:Boolean = false;
			
			/**
			 * This function is called once to initialize the controlPanel.
			 * Override this function to add additional control panel initialization code.
			 * Remeber to call super.initControlPanel() first.
			 */
			protected function initControlPanel():void
			{
				if (!_controlPanel && _editorFactory)
				{
					var component:Object = registerDisposableChild(this, _editorFactory.newInstance());
					if (component is ControlPanel)
					{
						if (component.hasOwnProperty(OUTER_DOCUMENT))
							component[OUTER_DOCUMENT] = this;
						if (component is ILinkableObjectEditor)
							(component as ILinkableObjectEditor).setTarget(this);
						_controlPanel = component as ControlPanel;
					}
					//TODO handle other cases
				}
				
				if (!_controlPanel && WeaveAPI.EditorManager.getEditorClass(this))
				{
					_controlPanel = newDisposableChild(this, ControlPanel);
					var editor:UIComponent = WeaveAPI.EditorManager.getNewEditor(this) as UIComponent;
					addChild(_controlPanel);
					removeChild(_controlPanel);
					_controlPanel.tabNavigator.addChild(editor);
				}
				
				if (_controlPanel)
				{
					_controlPanel.title = _controlPanel._defaultTitle = ControlPanel.getControlPanelTitle(this);
					_controlPanel.enableSubMenu.value = true;
					_controlPanel.sessionEditorTarget = this;
					_controlPanel.targets = [this];
				}
			}
			
			public function toggleControlPanel():void
			{
				if (!_controlPanelInitialized)
				{
					_controlPanelInitialized = true;
					initControlPanel();
				}

				if (_controlPanel)
				{
					if (!_controlPanel.parent)
						PopUpManager.addPopUp(_controlPanel, WeaveAPI.topLevelApplication as UIComponent);
					_controlPanel.sendWindowToForeground();
					_controlPanel.reposition();
					_controlPanel.copyCoordinatesFromSessionedProperties();
				}
				else
				{
					SessionStateEditor.openDefaultEditor(this);
				}
			}
			
			/**
			 * This will reposition the window with default coordinates.
			 */
			public function reposition():void
			{
				panelX.value = '' + int(2 + Math.random() * 6) + "%";
				panelY.value = '' + int(2 + Math.random() * 6) + "%";
				panelWidth.value = "50%";
				panelHeight.value = "50%";
			}
			
			private function setupButtonIcons(button:Button, iconClassOrArray_0icon_1over_2down:Object):void
			{
				var icons:Array = iconClassOrArray_0icon_1over_2down as Array;
				var icon:Class = icons ? icons[0] : iconClassOrArray_0icon_1over_2down as Class;
				
				button.setStyle("icon", icon);
				button.setStyle("overIcon", (icons && icons[1]) || icon);
				button.setStyle("downIcon", (icons && icons[2]) || icon);
			}
			
			private function setupControlButton(button:Button, iconClassOrArray_0icon_1over_2down:Object, clickHandler:Function, tooltip:String = null):void
			{
				if (iconClassOrArray_0icon_1over_2down)
					setupButtonIcons(button, iconClassOrArray_0icon_1over_2down);
				
				button.toolTip = lang(tooltip);
				
				button.setStyle("fontFamily",    "Arial");
				button.setStyle("color", 0x000000);
				button.setStyle("paddingBottom", 0);
				button.setStyle("paddingLeft",   0);
				button.setStyle("paddingRight",  0);
				button.setStyle("paddingTop",    0);
				button.setStyle("fontSize",      12);
				button.setStyle("fontWeight",    "bold");
				button.setStyle("cornerRadius",  0);
				
				button.setStyle("fillAlphas", [1,1] );
				button.setStyle("fillColors", [_titleBarButtonBackgroundColor, _titleBarButtonBackgroundColor] );
				
				button.addEventListener(MouseEvent.MOUSE_DOWN, function (event:MouseEvent):void { event.stopPropagation(); });
				
				if (clickHandler != null)
				{
					var buttonListener:Function = function(e:MouseEvent):*
					{
						clickHandler();
						e.stopImmediatePropagation();
					};
					button.addEventListener(MouseEvent.CLICK, buttonListener);
				}
				button.width = buttonSize;
				button.height = buttonSize;
				button.buttonMode = true;
				
				button.graphics.clear();
				button.graphics.beginFill(0,0);
				DrawUtils.clearLineStyle(button.graphics);
				button.graphics.drawRect(-spaceBetweenButtons/2, -spaceBetweenButtons/2, buttonSize + spaceBetweenButtons, buttonSize + spaceBetweenButtons);
				button.graphics.endFill();
			}
			
			public function getTotalIconAreaWidth():int 
			{
				return getLeftIconAreaWidth() + getRightIconAreaWidth();
			}
			
			private function getLeftIconAreaWidth():int
			{
				var w:int = buttonOffsetFromSide;
				for each (var button:Button in [userControlButton, subMenuButton, attributeButton, toggleButton])
					if (button.parent)
						w += buttonSize + spaceBetweenButtons;
				return w;
			}
			
			private function getRightIconAreaWidth():int
			{
				var w:int = buttonOffsetFromSide;
				for each (var button:Button in [zOrderButton, minimizeButton, maximizeButton, closePanelButton])
					if (button.parent)
						w += buttonSize + spaceBetweenButtons;
				return w;
			}
			
			private var _prevShouldShowAttributeButton:Boolean = false;
			private function updateButtonsIfSelectableAttributesChanged():void
			{
				if (_prevShouldShowAttributeButton != shouldShowAttributeButton())
				{
					_prevShouldShowAttributeButton = !_prevShouldShowAttributeButton;
					updateButtons();
				}
			}
			
			private function shouldShowUserControlButton():Boolean
			{
				return Weave.properties.enableToolControls.value
					&& (_controlPanel || _editorFactory || WeaveAPI.EditorManager.getEditorClass(this));
			}
			
			private function shouldShowAttributeButton():Boolean
			{
				return Weave.properties.enableToolControls.value
					&& this is ISelectableAttributes
					&& (this as ISelectableAttributes).getSelectableAttributes().length;
			}
			
			private function updateButtons():void
			{
				// don't do anything if not added to a parent to avoid errors like the following:
				/*
				ArgumentError: Error #2004: One of the parameters is invalid.
				at flash.display::Graphics/drawRoundRect()
				at mx.skins::ProgrammaticSkin/drawRoundRect()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\skins\ProgrammaticSkin.as:763]
				at mx.skins.halo::ButtonSkin/updateDisplayList()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\skins\halo\ButtonSkin.as:217]
				at mx.skins::ProgrammaticSkin/validateDisplayList()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\skins\ProgrammaticSkin.as:421]
				at mx.managers::LayoutManager/validateDisplayList()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\managers\LayoutManager.as:622]
				at mx.managers::LayoutManager/doPhasedInstantiation()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\managers\LayoutManager.as:695]
				at Function/http://adobe.com/AS3/2006/builtin::apply()
				at mx.core::UIComponent/callLaterDispatcher2()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\core\UIComponent.as:8744]
				at mx.core::UIComponent/callLaterDispatcher()[C:\autobuild\3.5.0\frameworks\projects\framework\src\mx\core\UIComponent.as:8684]
				*/
				if (!parent)
				{
					callLater(updateButtons);
					return;
				}
				
				// centered vertically
				var offsetFromTop:int = Math.ceil((getHeaderHeight() - buttonSize) / 2 + getStyle("borderThicknessTop") / 2);
				var leftButtonX:int = buttonOffsetFromSide;
				var rightButtonX:int = unscaledWidth - buttonSize - buttonOffsetFromSide + 1;
				
				// we only need to update title buttons if the height is > 0, otherwise do not show the buttons
				var showButtons:Boolean = getStyle("headerHeight") > 0;
				var buttons:Array, conditions:Array, i:int, button:Button;
				
				// left side
				buttons = [userControlButton, subMenuButton, attributeButton, toggleButton];
				conditions = [
					shouldShowUserControlButton(),
					enableSubMenu.value,
					shouldShowAttributeButton(),
					shouldShowAttributeButton()
				];
				for (i = 0; i < buttons.length; i++)
				{
					button = buttons[i];
					if (showButtons && leftButtonX < rightButtonX && conditions[i])
					{
						if (titleBar != button.parent)
						{
							button.setStyle("cornerRadius", buttonRadius.value);
							button.y = offsetFromTop;
							button.width = buttonSize;
							button.height = buttonSize;
							titleBar.addChild(button);
						}
						button.x = leftButtonX;
						leftButtonX += buttonSize + spaceBetweenButtons;
					}
					else if (titleBar == button.parent)
						titleBar.removeChild(button);
				}
				
				// right side
				buttons = [closePanelButton, maximizeButton, minimizeButton, zOrderButton];
				conditions = [closeable.value, maximizable.value, minimizable.value, enableZOrder.value];
				for (i = 0; i < buttons.length; i++)
				{
					button = buttons[i];
					if (showButtons && leftButtonX < rightButtonX && conditions[i])
					{
						if (titleBar != button.parent)
						{
							button.setStyle("cornerRadius", buttonRadius.value);
							button.y = offsetFromTop;
							button.width = buttonSize;
							button.height = buttonSize;
							titleBar.addChild(button);
						}
						button.x = rightButtonX;
						rightButtonX -= buttonSize + spaceBetweenButtons;
					}
					else if (titleBar == button.parent)
						titleBar.removeChild(button);
				}
				updateBorders();
				layoutChrome(unscaledWidth, unscaledHeight);
			}
			
			override protected function layoutChrome(unscaledWidth:Number, unscaledHeight:Number):void
			{
				super.layoutChrome(unscaledWidth, unscaledHeight);
				// shift title text to make room for buttons on the upper-left corner
				if (!titleTextField)
					return;
				
				titleTextField.x = getLeftIconAreaWidth();	
				// modifed from Panel.as code for the titleTextField
				//getLeftIconAreaWidth... getRightIconAreaWidth should be getRightIconAreaWidth
				// the text has to be set each time because truncateToFit() is destructive of the textField's text variable
				titleTextField.text = title;
				titleTextField.width = Math.max(0, unscaledWidth - titleTextField.x - getRightIconAreaWidth());
				titleTextField.truncateToFit();
				handleTitleTextFormatChange();
			}
			
			override protected function commitProperties():void
			{
				minHeight = borderMetrics.top + borderMetrics.bottom;
				
				super.commitProperties();
			}
			
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				// force pixel boundaries
				unscaledWidth = Math.round(unscaledWidth);
				unscaledHeight = Math.round(unscaledHeight);
				super.updateDisplayList(unscaledWidth, unscaledHeight);
				
				updateButtons();
				
				if (controlBar)
					controlBar.visible = !minimized.value;
				
				_dragCanvas.graphics.clear();
				
				if (isNaN(unscaledHeight))
					return;
				
				// draw invisible halo around the inside of the window to intercept mouse events for resizing
				_dragCanvas.width = width;
				_dragCanvas.height = height;
				UIUtils.drawInvisibleHalo(_dragCanvas, -resizeBorderThickness);

				if (_enableMoveResize || _moveImage.visible)
				{
					// choose the thin border color to be black or white based on the brightness of the background
					var bgColor:Number = borderIsVisible ? getStyle('borderColor') : getStyle('backgroundColor');
					var thinBorderColor:Number = StandardLib.getColorLuma(bgColor) < 0x80 ? 0xFFFFFF : 0x000000;
					_dragCanvas.graphics.lineStyle(1, thinBorderColor, thinBorderAlpha, false, LineScaleMode.NONE);
					_dragCanvas.graphics.drawRect(0, 0, Math.round(width)-1, Math.round(height)-1);
				}
			}
			
			protected function handleAttributeButtonClick():void
			{
				openAttributeSelector();
			}
			
			protected function handleToggleButtonClick():void {
				Alert.show("Toggling");
			}
			
			public function openAttributeSelector(attrIndex:int = 0):AttributeSelectorPanel
			{
				var tool:ISelectableAttributes = this as ISelectableAttributes;
				if (tool)
				{
					var attrs:Array = tool.getSelectableAttributes();
					var names:Array = tool.getSelectableAttributeNames();
					if (attrs && attrs[attrIndex])
					{
						return AttributeSelectorPanel.open(attrs[attrIndex], names[attrIndex], false, tool);
					}
				}
				return null;
			}
			
			protected function handleMinimizeButtonClick():void
			{
				var hashMap:ILinkableHashMap = getLinkableOwner(this) as ILinkableHashMap;
				if (WeaveAPI.StageUtils.shiftKey && hashMap)
				{
					for each (var panel:DraggablePanel in hashMap.getObjects(DraggablePanel))
						panel.minimizePanel();
				}
				else
				{
					minimizePanel();
				}
			}
			
			private function handleMinimizedChange():void
			{
				if (minimized.value) // minimize
				{
					enabled = visible = false;
					if (!minimizedComponentVersion)
						minimizedComponentVersion = VisTaskbar.instance.addMinimizedComponent(this, restorePanel);
				}
				else // restore
				{
					enabled = visible = true;
					if (minimizedComponentVersion)
						VisTaskbar.instance.removeMinimizedComponent(minimizedComponentVersion);
					minimizedComponentVersion = null;
					copyCoordinatesFromSessionedProperties();
					
					// this fixes the display bugs that occur when restoring a minimized window
					updateBorders();
				}
			}
			
			public function minimizePanel():void
			{
				if (_controlPanel)
					_controlPanel.removePanel();
				minimized.value = true;
			}
			
			public function restorePanel():void
			{
				sendWindowToForeground();
				if (_controlPanel)
					_controlPanel.sendWindowToForeground();
				minimized.value = false;
			}
			
			/**
			 * This will be called when this object is no longer needed.
			 * Classes that extend this class should override this function and call super.dispose().
			 */
			public function dispose():void
			{
				CustomCursorManager.removeCursor(draggablePanelCursorID);
				
				if (minimizedComponentVersion)
					VisTaskbar.instance.removeMinimizedComponent(minimizedComponentVersion);
				minimizedComponentVersion = null;
				
				removeEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown, true);
				removeEventListener(DragEvent.DRAG_ENTER, handleDragEnter, true);
				removeEventListener(DragEvent.DRAG_ENTER, handleDragEnter);
				
				if (titleBar != null)
				{
					titleBar.removeEventListener(MouseEvent.MOUSE_DOWN, handleTitleBarMouseDown);
					titleBar.removeEventListener(MouseEvent.DOUBLE_CLICK, handleTitleBarDoubleClick);
				}
			}
			
			private function handleDragEnter(event:DragEvent):void
			{
				restorePanel();
			}
			
			public function get escapeKeyClosesPanel():Boolean
			{
				return _escapeKeyClosesPanel;
			}
			
			/**
			 * Set this to true to allow the ESCAPE key to close this panel.
			 */
			public function set escapeKeyClosesPanel(value:Boolean):void
			{
				_escapeKeyClosesPanel = value;
				if (value)
					WeaveAPI.StageUtils.addEventCallback(KeyboardEvent.KEY_DOWN, this, handleKeyDown);
				else
					WeaveAPI.StageUtils.removeEventCallback(KeyboardEvent.KEY_DOWN, handleKeyDown);
			}
			
			private function handleKeyDown():void
			{
				var event:KeyboardEvent = WeaveAPI.StageUtils.keyboardEvent;
				if (parent && event && event.keyCode == Keyboard.ESCAPE)
				{
					var i:int;
					
					// if there is a child with name=modalWindow, don't handle escape key
					for (i = 0; i < systemManager.numChildren; i++)
						if (systemManager.getChildAt(i).name == 'modalWindow')
							return;
					
					// find the top-most draggable panel with escapeKeyClosesPanel=true
					for (i = parent.numChildren; i--;)
					{
						var panel:DraggablePanel = parent.getChildAt(i) as DraggablePanel;
						if (panel && panel.escapeKeyClosesPanel)
						{
							if (panel == this)
								panel.handleEscapeKey();
							// we don't want to do anything more
							return;
						}
					}
				}
			}
			
			/**
			 * This function gets called when the user presses ESCAPE and escapeKeyClosesPanel has been set to true.
			 */
			protected function handleEscapeKey():void
			{
				// don't remove immediately because we don't want multiple windows to close in handleKeyDown()
				callLater(removePanel);
			}
			
			
			
			
			
			
			/**************************************************************************
			 ************************** BEGIN STATIC SECTION **************************/
			
			public static const TOOLTIP_MOVE:String = "Click for menu or drag to move";
			public static const TOOLTIP_CONTROLS:String = "Change settings";
			public static const TOOLTIP_SUBMENU:String = "Menu";
			public static const TOOLTIP_ATTRIBUTES:String = "Change attributes";
			public static const TOOLTIP_TOGGLE:String = "Toggle graph";
			public static const TOOLTIP_ZORDER:String = "Toggle always above or below";
			public static const TOOLTIP_ZORDER_MENU:String = "Z-Order";
			public static const TOOLTIP_MINIMIZE:String = "Minimize";
			public static const TOOLTIP_MAXIMIZE:String = "Maximize";
			public static const TOOLTIP_RESTORE:String = "Restore Down";
			public static const TOOLTIP_CLOSE:String = "Close";
			
			private static const _instances:Dictionary = new Dictionary(); // Class -> DraggablePanel   or   DraggablePanel -> DisplayObject
			private static const _maximizedCoordinates:Object = {x: "0%", y: "0%", width: "100%", height: "100%"};
			private static const resizeBorderThickness:int = 5;
			public static var adminMode:Boolean = false;
			public static var activePanel:DraggablePanel = null;
			public static var thinBorderAlpha:Number = 0.1;
			
			
			/**
			 * This function will create and reuse a static instance of DraggablePanel for each type of object requested.
			 * @param classDef A Class extending DraggablePanel or DisplayObject.
			 * @return The static instance of the given class.
			 */
			public static function getStaticInstance(draggablePanelClass:Class):*
			{
				var instance:DraggablePanel = _instances[draggablePanelClass] as DraggablePanel;
				if (!instance)
				{
					var qname:String = getQualifiedClassName(draggablePanelClass);
					var dpqname:String = getQualifiedClassName(DraggablePanel);
					var displayObject:DisplayObject = new draggablePanelClass();
					instance = displayObject as DraggablePanel;
					if (!instance)
					{
						instance = new DraggablePanel();
						instance.addChild(displayObject);
					}
					_instances[draggablePanelClass] = instance;
					_instances[instance] = displayObject;
					instance.enableZOrder.value = false;
				}
				return _instances[instance];
			}
			
			/**
			 * This function will create and reuse a static instance of DraggablePanel for each type of object requested, and add it as a popup.
			 * @param classDef A Class extending DraggablePanel or DisplayObject.
			 * @return The static instance of the given class.
			 */
			public static function openStaticInstance(draggablePanelClass:Class):*
			{
				var displayObject:DisplayObject = getStaticInstance(draggablePanelClass);
				var instance:DraggablePanel = displayObject as DraggablePanel || _instances[draggablePanelClass] as DraggablePanel;
				if (!instance.parent)
					PopUpManager.addPopUp(instance, WeaveAPI.topLevelApplication as UIComponent);
				instance.restorePanel();
				
				instance.reposition();
				instance.copyCoordinatesFromSessionedProperties();
				
				var xSpace:Number = Math.max(0, instance.parent.width - instance.width);
				var ySpace:Number = Math.max(0, instance.parent.height - instance.height);
				var xSpread:Number = Math.min(100, xSpace / 4);
				var ySpread:Number = Math.min(100, ySpace / 4);
				instance.panelX.value = String(int(xSpace/2 - xSpread/2 + xSpread * Math.random()));
				instance.panelY.value = String(int(ySpace/2 - ySpread/2 + ySpread * Math.random()));
				
				return displayObject;
			}
			
			public static function get activePanelName():String
			{
				return Weave.root.getName(activePanel);
			}
			
			public static function getTopPanel():DraggablePanel
			{
				var children:Array = WeaveAPI.globalHashMap.getObjects(DraggablePanel);
				while (children.length)
				{
					var panel:DraggablePanel = children.pop() as DraggablePanel;
					if (panel.visible)
						return panel;
				}
				return null;
			}
			public static function getTopPanelName():String
			{
				return Weave.root.getName(getTopPanel());
			}
			
			/**
			 * @return an Array containing all DraggablePanels on stage that are not minimized
			 *
			 * @author kmanohar
			 */		
			public static function getWindowsOnStage():Array
			{
				var panels:Array = WeaveAPI.globalHashMap.getObjects(DraggablePanel);
				var panelsOnStage:Array = [];
				
				for each (var panel:DraggablePanel in panels)
				{
					if (!panel.minimized.value) 
						panelsOnStage.push(panel);
				}
				return panelsOnStage;
			}
			/**
			 * This function tiles all the DraggablePanels on stage
			 * 
			 * @TODO create a ui for this so the user can specify how to divide the stage
			 * 
			 * @author kmanohar
			 */		
			public static function tileWindows():void
			{
				var panels:Array = getWindowsOnStage();
				var numPanels:uint = panels.length;
				if (!numPanels)
					return;
				
				var gridLength:Number = Math.ceil(Math.sqrt(numPanels));
				
				var rows:uint = gridLength; 
				var columns:uint = gridLength;
				
				if (gridLength*gridLength != numPanels)
				{	
					rows = Math.round(Math.sqrt(numPanels));
					columns = gridLength;
				}			
				
				var xPos:Number = 0;
				var yPos:Number = 0;
				var firstPanel:DraggablePanel = panels[0] as DraggablePanel;
				var taller:Boolean = firstPanel.parent.width < firstPanel.parent.height;
				var width:Number = 100/(taller ? rows : columns);
				var height:Number = 100/(taller ? columns : rows);
				
				var i:int = 0;
				for each (var dp:DraggablePanel in panels)
				{
					dp.maximized.value = false;
					dp.panelX.value = xPos.toString() + "%";
					dp.panelY.value = yPos.toString() + "%";
					
					dp.panelHeight.value = height.toString() + "%";
					dp.panelWidth.value = width.toString() + "%";
					if (i == (panels.length - 1))
					{
						// expand to fill the width
						dp.panelWidth.value = (100-xPos).toString() + "%";
					}
					
					xPos += width;
					if (xPos >= 100)
						xPos = 0;
					if (!xPos)
						yPos += height ;
					i++;
				}
			}
			/**
			 * This function arranges all DraggablePanels along a diagonal
			 * 
			 * @author kmanohar
			 */
			public static function cascadeWindows():void
			{
				var panels:Array = getWindowsOnStage();
				if (!panels.length)
					return;
				
				var increment:Number = 50/panels.length;
				var dist:Number = 0 ;
				
				for each (var dp:DraggablePanel in panels)
				{				
					dp.panelX.value = dp.panelY.value = dist.toString()+"%";			
					dp.panelHeight.value = dp.panelWidth.value = "50%" ;	
					
					dist += increment;
				}
			}
			
			internal static const OUTER_DOCUMENT:String = 'outerDocument';
			
			/**
			 * Embedded cursors
			 */
			public static const CURSOR_RESIZE_TOP_BOTTOM:String = "resizeTopBottom";
			public static const CURSOR_RESIZE_LEFT_RIGHT:String = "resizeLeftRight";
			public static const CURSOR_RESIZE_TOPLEFT_BOTTOMRIGHT:String = "resizeTLBR";
			public static const CURSOR_RESIZE_TOPRIGHT_BOTTOMLEFT:String = "resizeTRBL";
			[Embed(source="/weave/resources/images/resize_TB.png")] private static var _resizeTBCursor:Class;
			[Embed(source="/weave/resources/images/resize_LR.png")] private static var _resizeLRCursor:Class;
			[Embed(source="/weave/resources/images/resize_TL-BR.png")] private static var _resizeTLBRCursor:Class;
			[Embed(source="/weave/resources/images/resize_TR-BL.png")] private static var _resizeTRBLCursor:Class;
			CustomCursorManager.registerEmbeddedCursor(CURSOR_RESIZE_TOP_BOTTOM, _resizeTBCursor, NaN, NaN);
			CustomCursorManager.registerEmbeddedCursor(CURSOR_RESIZE_LEFT_RIGHT, _resizeLRCursor, NaN, NaN);
			CustomCursorManager.registerEmbeddedCursor(CURSOR_RESIZE_TOPLEFT_BOTTOMRIGHT, _resizeTLBRCursor, NaN, NaN);
			CustomCursorManager.registerEmbeddedCursor(CURSOR_RESIZE_TOPRIGHT_BOTTOMLEFT, _resizeTRBLCursor, NaN, NaN);
			
			/**
			 * Embedded icons
			 */
			[Embed(source="/weave/resources/images/panMode.png")] private static var MoveIcon:Class;
			
			[Embed(source="/weave/resources/images/gear6_13x13_h.png")] private static var _userControlIcon:Class;
			[Embed(source="/weave/resources/images/gear6_13x13_v.png")] private static var _userControlIcon2:Class;
			[Embed(source="/weave/resources/images/alpha_11x11.png")] private static var _attributeIcon:Class;
			
			[Embed(source="/weave/resources/images/z-order.png")] private static var icon_zOrder:Class;
			[Embed(source="/weave/resources/images/z-order-reverse.png")] private static var icon_zOrderReverse:Class;
			
			[Embed(source="/weave/resources/images/always-on-top-gray.png")] private static var icon_zOrderAbove:Class;
			[Embed(source="/weave/resources/images/always-on-top.png")] private static var icon_zOrderAbove_color:Class;
			
			[Embed(source="/weave/resources/images/always-on-back-gray.png")] private static var icon_zOrderBelow:Class;
			[Embed(source="/weave/resources/images/always-on-back.png")] private static var icon_zOrderBelow_color:Class;
			
			[Embed(source="/weave/resources/images/minimize_icon.png")] private static var _minimizeIcon:Class;
			[Embed(source="/weave/resources/images/maximize_icon.png")] private static var _maximizeIcon:Class;
			[Embed(source="/weave/resources/images/unmaximize_icon.png")] private static var _unmaximizeIcon:Class;
			
			[Embed(source="/weave/resources/images/close_icon.png")] private static var _closeIcon:Class;
			[Embed(source="/weave/resources/images/close_icon_red.png")] private static var _closeIconColor:Class;
			[Embed(source="/weave/resources/images/close_icon_red2.png")] private static var _closeIconColor2:Class;
			
			/************************** END STATIC SECTION **************************
			 ************************************************************************/
			
			/**
			 * Backwards compatibility
			 */
			[Deprecated(replacement="panelTitle")] public function set toolTitle(value:String):void { panelTitle.value = value; }
			[Deprecated(replacement="enableBorders")] public function set hideBorders(value:Boolean):void { enableBorders.value = !value; }
			[Deprecated(replacement="enableMoveResize")] public function set draggable(value:Boolean):void { enableMoveResize.value = value; }
			[Deprecated(replacement="enableMoveResize")] public function set resizeable(value:Boolean):void { enableMoveResize.value = value; }
			[Deprecated(replacement="zOrder")] public function set pinned(value:Boolean):void { if (value) zOrder.value = 1; }
			[Deprecated(replacement="zOrder")] public function set pinnedToBack(value:Boolean):void { if (value) zOrder.value = -1; }
			[Deprecated(replacement="enableZOrder")] public function set pinnable(value:Boolean):void { enableZOrder.value = value; }
			[Deprecated(replacement="enableZOrder")] public function set pinnableToBack(value:Boolean):void { if (value) enableZOrder.value = true; }
		]]>
	</mx:Script>
</mx:TitleWindow>
