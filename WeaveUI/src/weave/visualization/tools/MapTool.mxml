<?xml version="1.0" encoding="utf-8"?>
<!--
/* ***** BEGIN LICENSE BLOCK *****
 *
 * This file is part of Weave.
 *
 * The Initial Developer of Weave is the Institute for Visualization
 * and Perception Research at the University of Massachusetts Lowell.
 * Portions created by the Initial Developer are Copyright (C) 2008-2015
 * the Initial Developer. All Rights Reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/.
 * 
 * ***** END LICENSE BLOCK ***** */
-->
<SimpleVisTool xmlns="weave.visualization.tools.*" 
	     xmlns:mx="http://www.adobe.com/2006/mxml"
	     xmlns:ui="weave.ui.*"
		 xmlns:managers="weave.editors.managers.*"
		 implements="weave.api.ui.IVisTool_Basic"
	     >
	<mx:Script>
		<![CDATA[
			import mx.controls.CheckBox;
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			import mx.utils.ObjectUtil;
			
			import weave.Weave;
			import weave.api.copySessionState;
			import weave.api.data.ColumnMetadata;
			import weave.api.data.DataType;
			import weave.api.data.IAttributeColumn;
			import weave.api.data.IColumnReference;
			import weave.api.getCallbackCollection;
			import weave.api.linkBindableProperty;
			import weave.api.linkSessionState;
			import weave.api.newDisposableChild;
			import weave.api.registerLinkableChild;
			import weave.api.services.IWMSService;
			import weave.api.ui.IObjectWithDescription;
			import weave.api.ui.IPlotter;
			import weave.api.ui.IVisTool;
			import weave.compiler.StandardLib;
			import weave.core.LinkableBoolean;
			import weave.core.LinkableNumber;
			import weave.core.LinkableString;
			import weave.core.SessionManager;
			import weave.core.UIUtils;
			import weave.data.AttributeColumns.DynamicColumn;
			import weave.data.AttributeColumns.ReferencedColumn;
			import weave.data.AttributeColumns.ReprojectedGeometryColumn;
			import weave.editors.SimpleAxisEditor;
			import weave.editors.WindowSettingsEditor;
			import weave.editors.managers.LayerListComponent;
			import weave.menus.WeaveMenuItem;
			import weave.primitives.Bounds2D;
			import weave.ui.AttributeMenuTool;
			import weave.ui.SubMenu;
			import weave.ui.VariableListController;
			import weave.utils.ColumnUtils;
			import weave.utils.DrawUtils;
			import weave.utils.ProbeTextUtils;
			import weave.visualization.layers.InteractionController;
			import weave.visualization.layers.LayerSettings;
			import weave.visualization.plotters.AbstractGlyphPlotter;
			import weave.visualization.plotters.GeometryLabelPlotter;
			import weave.visualization.plotters.GeometryPlotter;
			import weave.visualization.plotters.GeometryRelationPlotter;
			import weave.visualization.plotters.ScatterPlotPlotter;
			import weave.visualization.plotters.SingleImagePlotter;
			import weave.visualization.plotters.WMSPlotter;

			WeaveAPI.ClassRegistry.registerImplementation(IVisTool, MapTool, "Map");
			
			override protected function inConstructor():void
			{
				super.inConstructor();
				
				AttributeMenuTool.hack_skipToolTargets[this] = true;
			}
			
			private function isGeomColumnOrRef(obj:Object, i:*, a:*):Boolean
			{
				var col:IAttributeColumn = obj as IAttributeColumn;
				if (col)
					return col.getMetadata(ColumnMetadata.DATA_TYPE) == DataType.GEOMETRY;
				
				var ref:IColumnReference = obj as IColumnReference;
				if (ref)
				{
					var meta:Object = ref.getColumnMetadata();
					return meta && meta[ColumnMetadata.DATA_TYPE] == DataType.GEOMETRY;
				}
				
				return false;
			}
			
			override public function initSelectableAttributes(input:Array):void
			{
				var geomColumns:Array = input.filter(isGeomColumnOrRef);
				var nonGeomColumns:Array = input.filter(function(o:*, i:*, a:*):Boolean { return !isGeomColumnOrRef(o, i, a); });
				if (geomColumns.length)
				{
					visualization.plotManager.plotters.removeAllObjects();
					
					var geomColumn:Object = geomColumns[0];
					var gp:GeometryPlotter = LayerListComponent.addPlotterAndEdit(visualization, GeometryPlotter, false);
					if (gp)
					{
						ColumnUtils.initSelectableAttribute(gp.geometryColumn, geomColumn);
						if (!Weave.defaultColorDataColumn.getInternalColumn())
							ColumnUtils.initSelectableAttribute(Weave.defaultColorDataColumn, nonGeomColumns[0]);
					}
				}
			}
			
			/**
			 * This function moves the overview window in front of the visualization
			 */
			private function bringOverviewToTop():void
			{
				children.setNameOrder([OVERVIEW_PANEL_NAME]);
			}
			
			/**
			 * This is the projection of the map visualization.
			 */
			public const projectionSRS:LinkableString = registerLinkableChild(this, new LinkableString(null, projectionVerifier));
			// this function returns true if the projection SRS code is acceptable
			internal function projectionVerifier(srs:String):Boolean
			{
				// allow no projection
				if (srs == null || srs == '')
					return true;
				return WeaveAPI.ProjectionManager.projectionExists(srs);
			}
			
			public const includeToolAttributesInProbe:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), updateProbeColumns);
			
			// the keys in this Dictionary are LinkableStrings that have been linked to projectionSRS.
			private var _linkedProjectionVariablesLookup:Dictionary = new Dictionary(true);
			[Bindable] internal var _projComboBoxData:Array = [];
			
			/**
			 * This function links the MapTool.projectionSRS variable with another LinkableString.
			 */
			private function linkProjection(otherVariable:LinkableString):void
			{
				if (_linkedProjectionVariablesLookup[otherVariable])
					return;
				_linkedProjectionVariablesLookup[otherVariable] = true;
				
				// if map tool specifies a valid projection, use map tool value as the primary value
				if (WeaveAPI.ProjectionManager.projectionExists(projectionSRS.value))
					linkSessionState(projectionSRS, otherVariable);
				else
					linkSessionState(otherVariable, projectionSRS);
			}
			
			private function handleLayerSettingsChange():void
			{
				visualization.plotManager.layerSettings.delayCallbacks();
				
				// prevent WMS layers from being selectable
				for each (var name:String in visualization.plotManager.plotters.getNames(WMSPlotter))
					visualization.plotManager.getLayerSettings(name).selectable.value = false;
				
				visualization.plotManager.layerSettings.resumeCallbacks();
			}
			private function handlePlottersChange():void
			{
				var ourSRS:String = projectionSRS.value || null;
				_projComboBoxData.length = 0;
				// TEMPORARY: set the selected item in the combo box because changing the data provider 
				// will reset the text field
				if (WeaveAPI.ProjectionManager.projectionExists(ourSRS))
				{
					_projComboBoxData.push(ourSRS);
					projComboBox_selectedItem = ourSRS;
				}
				
				var projString:String;
				
				// make sure glyph layer projections are identical
				var glyphPlotters:Array = WeaveAPI.SessionManager.getLinkableDescendants(visualization.plotManager.plotters, AbstractGlyphPlotter);
				for each (var glyphPlotter:AbstractGlyphPlotter in glyphPlotters)
				{
					linkProjection(glyphPlotter.destinationProjection);
					projString = glyphPlotter.sourceProjection.value;
					if (projString && _projComboBoxData.indexOf(projString) < 0)
						_projComboBoxData.push(projString);
				}
				
				// make sure wms layer projections are identical
				var wmsPlotters:Array = WeaveAPI.SessionManager.getLinkableDescendants(visualization.plotManager.plotters, WMSPlotter);
				for each (var wmsPlotter:WMSPlotter in wmsPlotters)
				{
					linkProjection(wmsPlotter.srs);
					projString = wmsPlotter.sourceSRS;
					if (projString && _projComboBoxData.indexOf(projString) < 0)
						_projComboBoxData.push(projString);
				}
				
				// make sure all geometry column projections are identical
				var reprojectedColumns:Array = WeaveAPI.SessionManager.getLinkableDescendants(visualization.plotManager.plotters, ReprojectedGeometryColumn);
				for each (var column:ReprojectedGeometryColumn in reprojectedColumns)
				{
					linkProjection(column.projectionSRS);
					projString = column.internalDynamicColumn.getMetadata(ColumnMetadata.PROJECTION);
					if (projString && _projComboBoxData.indexOf(projString) < 0)
						_projComboBoxData.push(projString);					
				}
				
				updateProbeColumns();
				
				if (zoomToBaseMap.value)
				{
					_baseMapZoomAuthority = null;
					wmsPlotters = visualization.plotManager.plotters.getObjects(WMSPlotter);
					for each (wmsPlotter in wmsPlotters)
					{
						if (ourSRS && wmsPlotter.sourceSRS != ourSRS)
							continue; // doesn't match projection
						
						var layerName:String = visualization.plotManager.plotters.getName(wmsPlotter);
						if (!visualization.plotManager.layerShouldBeRendered(layerName))
							continue; // not visible
						
						// the first visible wmsPlotter we find that matches the current projection is treated as the authority
						_baseMapZoomAuthority = wmsPlotter;
						break;
					}
					updateZoom();
				}
			}
			private function updateProbeColumns():void
			{
				if (includeToolAttributesInProbe.value)
				{
					visualization.additionalProbeColumns = [];
					// get all ReferencedColumn objects, excluding geometry columns
					var refCols:Array = WeaveAPI.SessionManager.getLinkableDescendants(visualization, ReferencedColumn);
					for each (var col:IAttributeColumn in refCols)
						if (ObjectUtil.stringCompare(ColumnUtils.getDataType(col), DataType.GEOMETRY, true) != 0) // non-geometry
							visualization.additionalProbeColumns.push(col);
				}
				else
					visualization.additionalProbeColumns = null;
			}
			
			override public function get defaultPanelTitle():String
			{
				// hack
				var dc:DynamicColumn = ColumnUtils.hack_findInternalDynamicColumn(Weave.defaultColorColumn);
				if (dc.getInternalColumn())
					return lang("Map of {0}", ColumnUtils.getTitle(dc));
				return lang("Map");
			}
			
			override protected function initControlPanel():void
			{
				super.initControlPanel();
				
				WindowSettingsEditor; // work around compiler error
				SimpleAxisEditor;
				
				windowEditor.addEventListener(FlexEvent.CREATION_COMPLETE, function(e:Event):* {
					if (windowEditor.titleControls.parent)
						windowEditor.titleControls.parent.removeChild(windowEditor.titleControls);
					windowEditor.addChildAt(axesEditor.titleControls, 0);
				});
				axesEditor.addEventListener(FlexEvent.CREATION_COMPLETE, function(e:Event):* {
					if (axesEditor.parent)
						axesEditor.parent.removeChild(axesEditor);
				});
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
				// make sure WMS layers are included in the full data bounds
				visualization.plotManager.includeNonSelectableLayersInAutoZoom.value = true;
				visualization.plotManager.includeNonSelectableLayersInAutoZoom.lock();
				
				visualization.plotManager.enableFixedAspectRatio.value = true;
				visualization.plotManager.enableAutoZoomToExtent.value = false;
				getCallbackCollection(visualization).addGroupedCallback(this, updateZoomSlider);
				
				// hack
				Weave.defaultColorDataColumn.addGroupedCallback(this, handlePanelTitleChange);
				Weave.properties.toolInteractions.defaultDragMode.addGroupedCallback(this, handleMouseModeChange);
				
				visualization.plotManager.hack_onUpdateZoom(updateZoom);
				visualization.plotManager.plotters.addGroupedCallback(this,handlePlottersChange,true);
				visualization.plotManager.plotters.addGroupedCallback(this,handleLayerSettingsChange,true);
				Weave.defaultColorDataColumn.addGroupedCallback(this,updateProbeColumns, true);
				
				linkBindableProperty(visualization.plotManager.minZoomLevel, this, "zoomSliderMinimum");
				linkBindableProperty(visualization.plotManager.maxZoomLevel, this, "zoomSliderMaximum");
				linkBindableProperty(zoomSliderHeight, zoomSlider, 'height');
				
				getCallbackCollection(visualization.plotManager.zoomBounds).addGroupedCallback(this, handleBoundsChange, true);
				
				initSelectionSubMenu();
			}
			
			private var selectionSubMenu:SubMenu;
			private function initSelectionSubMenu():void
			{
				selectionSubMenu = new SubMenu(selectModeButton, [
					menuItem(InteractionController.SELECTION_MODE_RECTANGLE, "Rectangular Selection"),
					menuItem(InteractionController.SELECTION_MODE_CIRCLE, "Circular Selection"),
					menuItem(InteractionController.SELECTION_MODE_LASSO, "Lasso Selection")/*,
					menuItem(InteractionController.SELECTION_MODE_POINT, "Point Selection")*/
				]);
				selectionSubMenu.setSubMenuEvents([MouseEvent.MOUSE_DOWN], [MouseEvent.MOUSE_UP]);
				function menuItem(mode:String, label:String):Object {
					return {
						data: mode,
						label: lang(label),
						click: onClick,
						type: WeaveMenuItem.TYPE_RADIO,
						toggled: isToggled
					};
				}
				function onClick(item:WeaveMenuItem):void {
					Weave.properties.toolInteractions.defaultDragMode.value = InteractionController.SELECT;
					Weave.properties.selectionMode.value = item.data as String;
				}
				function isToggled(item:WeaveMenuItem):Boolean {
					return Weave.properties.toolInteractions.defaultDragMode.value == InteractionController.SELECT
						&& Weave.properties.selectionMode.value == item.data;
				}
			}
			
			private function handleMouseModeChange(event:Event = null):void
			{
				var defaultMode:String;
				if (event)
				{
					switch (event.target)
					{
						case panModeButton:
							defaultMode = InteractionController.PAN;
							break;
						default:
						case selectModeButton:
							defaultMode = InteractionController.SELECT;
							break;
						case selectModeSubtractButton:
							defaultMode = InteractionController.SELECT_REMOVE;
							break;
						case selectModeAddButton:
							defaultMode = InteractionController.SELECT_ADD;
							break;
						case zoomModeButton:
							defaultMode = InteractionController.ZOOM;
							Weave.properties.selectionMode.value = InteractionController.SELECTION_MODE_RECTANGLE; //to draw the blue rectangle
							break;
					}
					Weave.properties.toolInteractions.defaultDragMode.value = defaultMode;
				}
				defaultMode = Weave.properties.toolInteractions.defaultDragMode.value;
				
				var buttonMap:Object = {};
				buttonMap[InteractionController.PAN] = panModeButton;
				buttonMap[InteractionController.SELECT] = selectModeButton;
				buttonMap[InteractionController.SELECT_REMOVE] = selectModeSubtractButton;
				buttonMap[InteractionController.SELECT_ADD] = selectModeAddButton;
				buttonMap[InteractionController.ZOOM] = zoomModeButton;
				var selectedButton:Button = buttonMap[defaultMode];
				for each (var button:Button in buttonMap)
					button.selected = (button == selectedButton);
			}
			
			private function setCenterCoords():void
			{
//				var x:Number = MathLib.toNumber(xCenterCoord.text);
//				var y:Number = MathLib.toNumber(yCenterCoord.text);
//				visualization.dataBounds.copyTo(_tempBounds);
//				_tempBounds.setCenter(x, y);
//				visualization.dataBounds.copyFrom(_tempBounds);
			}
			
			public function updateZoomSlider():void
			{
				if (zoomSlider)
					scaleRangeTabZoomSlider_value = zoomSlider.value = visualization.getZoomLevel();
			}
			
			internal function handleZoomSliderChange(event:Event):void
			{
				if (UIUtils.hasFocus(event.currentTarget as UIComponent))
					visualization.setZoomLevel(event.currentTarget.value);
			}
			
			private function handleZoomInClick():void
			{
				visualization.plotManager.zoomBounds.getDataBounds(_tempBounds);
				_tempBounds.centeredResize(
					_tempBounds.getWidth() / visualization.zoomFactor.value,
					_tempBounds.getHeight() / visualization.zoomFactor.value
				);
				visualization.plotManager.setCheckedZoomDataBounds(_tempBounds);
			}
			
			private function handleZoomOutClick():void
			{
				visualization.plotManager.zoomBounds.getDataBounds(_tempBounds);
				_tempBounds.centeredResize(
					_tempBounds.getWidth() * visualization.zoomFactor.value,
					_tempBounds.getHeight() * visualization.zoomFactor.value
				);
				visualization.plotManager.setCheckedZoomDataBounds(_tempBounds);
			}
			
			private function handlePanButtonClick(xPan:Number, yPan:Number):void
			{
				var panPercent:Number = 0.3;
				
				visualization.plotManager.zoomBounds.getDataBounds(_tempBounds);
				_tempBounds.offset(
						_tempBounds.getWidth() * panPercent * xPan,
						_tempBounds.getHeight() * panPercent * yPan
					);
				visualization.plotManager.zoomBounds.setDataBounds(_tempBounds);
			}
			
			private var _tempBounds:Bounds2D = new Bounds2D();

			[Embed(source="/weave/resources/images/ocean_background2.jpg")]
			private static const BackgroundImage:Class;
			private static const backgroundImageBitmapData:BitmapData = (new BackgroundImage() as Bitmap).bitmapData;
			
			public const enableBackground:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), invalidateDisplayList);
			public const enableOverview:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(false), updateOverviewWindow);
			
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
			{
				super.updateDisplayList(unscaledWidth, unscaledHeight);
				
				//Needs to be called on the next frame, due to the background getting cleared afterwards by the super functions.
				callLater(drawBackground);
			}
			
			private function drawBackground():void
			{
				visualization.graphics.clear();
				if (enableBackground.value)
				{
					DrawUtils.clearLineStyle(visualization.graphics);
					visualization.graphics.beginBitmapFill(backgroundImageBitmapData);
					visualization.graphics.drawRect(0, 0, visualization.width, visualization.height);
					visualization.graphics.endFill();
				}
			}
			
			private function getDynamicGeomColumn(p:IPlotter):DynamicColumn
			{
				var gp:GeometryPlotter = p as GeometryPlotter;
				if (gp)
					return gp.geometryColumn.internalDynamicColumn;
				
				var glp:GeometryLabelPlotter = p as GeometryLabelPlotter;
				if (glp)
					return glp.geometryColumn.internalDynamicColumn;
				
				var grp:GeometryRelationPlotter = p as GeometryRelationPlotter;
				if (grp)
					return grp.geometryColumn.internalDynamicColumn;
				
				var agp:AbstractGlyphPlotter = p as AbstractGlyphPlotter;
				if (agp)
					return agp.dataX;
				
				return null;
			}
			
			internal function addGeomLayer():void
			{
				LayerListComponent.addPlotterAndEdit(visualization, GeometryPlotter);
			}
			
			internal function addLabelLayer():void
			{
				// get existing layers before they change
				var layerNames:Array = visualization.plotManager.plotters.getNames().reverse(); // top to bottom
				// if a layer is selected in the editor, check that one first.
				if (layersEditor.selectedPlotter)
					layerNames.unshift(layersEditor.selectedPlotterName);
				
				// create new plotter
				var plotter:GeometryLabelPlotter = LayerListComponent.addPlotterAndEdit(visualization, GeometryLabelPlotter);
				if (!plotter)
					return;
				
				// loop through existing layers to find geometry layer that we can add corresponding labels for
				for each (var layerName:String in layerNames)
				{
					var selected:DynamicColumn = getDynamicGeomColumn(visualization.plotManager.getPlotter(layerName));
					if (selected)
					{
						copySessionState(selected, getDynamicGeomColumn(plotter));
						
						// see if there is a matching column in probe headers
						for each (var header:IAttributeColumn in ProbeTextUtils.probeHeaderColumns.getObjects())
						{
							if (ColumnUtils.getKeyType(header) == ColumnUtils.getKeyType(selected))
							{
								plotter.text.requestLocalObjectCopy(header);
								break;
							}
						}
						// stop when we found geometry layer
						break;
					}
				}
			}
			
			internal function addBubbleLayer():void
			{
				// get existing layers before they change
				var layerNames:Array = visualization.plotManager.plotters.getNames().reverse(); // top to bottom
				// if a layer is selected in the editor, check that one first.
				if (layersEditor.selectedPlotter)
					layerNames.unshift(layersEditor.selectedPlotterName);
				
				// create new plotter
				var plotter:ScatterPlotPlotter = LayerListComponent.addPlotterAndEdit(visualization, ScatterPlotPlotter);
				if (!plotter)
					return;
				
				// set defaults
				copySessionState(ColumnUtils.hack_findInternalDynamicColumn(plotter.fill.color), plotter.sizeBy);
				
				// loop through existing layers to find geometry layer that we can add corresponding labels for
				for each (var layerName:String in layerNames)
				{
					var selected:DynamicColumn = getDynamicGeomColumn(visualization.plotManager.getPlotter(layerName));
					if (selected)
					{
						copySessionState(selected, plotter.dataX);
						copySessionState(selected, plotter.dataY);
						break;
					}
				}
			}
			
			internal function addRelationLayer():void
			{
				// get existing layers before they change
				var layerNames:Array = visualization.plotManager.plotters.getNames().reverse(); // top to bottom
				// if a layer is selected in the editor, check that one first.
				if (layersEditor.selectedPlotter)
					layerNames.unshift(layersEditor.selectedPlotterName);
				
				// create new plotter
				var plotter:GeometryRelationPlotter = LayerListComponent.addPlotterAndEdit(visualization, GeometryRelationPlotter);
				if (!plotter)
					return;
				
				// loop through existing layers to find geometry layer that we can add corresponding labels for
				for each (var layerName:String in layerNames)
				{
					var selected:DynamicColumn = getDynamicGeomColumn(visualization.plotManager.getPlotter(layerName));
					if (selected)
					{
						copySessionState(selected, getDynamicGeomColumn(plotter));
						break;
					}
				}
			}
			internal function addWMSLayer():void
			{
				var oldLayerNames:Array = visualization.plotManager.plotters.getNames();

				// create new plotter
				var plotter:WMSPlotter = LayerListComponent.addPlotterAndEdit(visualization, WMSPlotter);
				if (!plotter)
					return;
				
				// put old layers on top
				visualization.plotManager.plotters.setNameOrder(oldLayerNames);
			}

			private function handleBoundsChange():void
			{
				// update center coordinates text boxes
				visualization.plotManager.zoomBounds.getDataBounds(_tempBounds);
				centerCoords_text = lang(
					"{x: {0}, y: {1}}",
					StandardLib.roundSignificant(_tempBounds.getXCenter(), 6),
					StandardLib.roundSignificant(_tempBounds.getYCenter(), 6)
				);
			}
			
			public var overviewPanel:MapOverviewWindow;
			private const OVERVIEW_PANEL_NAME:String = "overview";
			
			private function updateOverviewWindow():void
			{				
				if (enableOverview.value)
				{
					overviewPanel = children.requestObject(OVERVIEW_PANEL_NAME, MapOverviewWindow, false); //not locked because it should be removable
					// catercorner to the mapControls 
					if (mapControls.top == 0)
						overviewPanel.panelY.value = "75%";
					if (mapControls.left == 0)
						overviewPanel.panelX.value = "75%";
					if (mapControls.bottom == 0)
						overviewPanel.panelY.value = "0%";
					if (mapControls.right == 0)
						overviewPanel.panelX.value = "0%";

					// remove overview window from parent's session state
					(WeaveAPI.SessionManager as SessionManager).excludeLinkableChildFromSessionState(children, overviewPanel);
					linkSessionState(visualization.plotManager.layerSettings, overviewPanel.visualization.plotManager.layerSettings);
					linkSessionState(visualization.plotManager.plotters, overviewPanel.visualization.plotManager.plotters);
					overviewPanel.parentZoomBounds = visualization.plotManager.zoomBounds;
					children.addGroupedCallback(this, bringOverviewToTop);
				}
				else
				{
					children.removeObject(OVERVIEW_PANEL_NAME);
				}
			}
			
			public function addMarker(name:String,url:String,x:Number,y:Number,width:Number=NaN,height:Number=NaN):void
			{
				var marker:SingleImagePlotter = visualization.plotManager.plotters.requestObject(name, SingleImagePlotter, false);
				marker.imageURL.value = url || SingleImagePlotter.RED_CIRCLE_IMAGE_URL;
				marker.dataX.value = x;
				marker.dataY.value = y;
				marker.dataWidth.value = width;
				marker.dataHeight.value = height;
			}

			public const showZoomControls:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true));
			public const showMouseModeControls:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true));
			
			private const TOP_LEFT:String = "Top left";
			private const TOP_RIGHT:String = "Top right";
			private const BOTTOM_LEFT:String = "Bottom left";
			private const BOTTOM_RIGHT:String = "Bottom right";
			internal const zoomControlsLocationsList:Array = [TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT];
			public const zoomControlsLocation:LinkableString = registerLinkableChild(this, new LinkableString(TOP_LEFT, verifyZoomControlsLocation), handleLocationChange, true);
			private function verifyZoomControlsLocation(value:String):Boolean { return zoomControlsLocationsList.indexOf(value) >= 0; }
			public function handleLocationChange():void 
			{
				if (!parent)
				{
					callLater(handleLocationChange);
					return;
				}
				
				// need to set all to NaN first because we can't set both top and bottom to 0, for example.
				mapControls.left = mapControls.right = mapControls.top = mapControls.bottom = NaN;
				var pos:String = zoomControlsLocation.value;
				if (pos == TOP_LEFT || pos == BOTTOM_LEFT)
					mapControls.left = 0;
				if (pos == TOP_RIGHT || pos == BOTTOM_RIGHT)
					mapControls.right = 0;
				if (pos == TOP_LEFT || pos == TOP_RIGHT)
					mapControls.top = 0;
				if (pos == BOTTOM_LEFT || pos == BOTTOM_RIGHT)
					mapControls.bottom = 0;
			}	
			
			public const zoomSliderHeight:LinkableNumber = registerLinkableChild(this, new LinkableNumber(100));
			
			public const zoomToBaseMap:LinkableBoolean = registerLinkableChild(this, new LinkableBoolean(true), handlePlottersChange, true);
			private var _baseMapZoomAuthority:WMSPlotter;
			private function updateZoom():void
			{
				if (!zoomToBaseMap.value || WeaveAPI.SessionManager.objectWasDisposed(_baseMapZoomAuthority))
				{
					_baseMapZoomAuthority = null;
				}
				else if (_baseMapZoomAuthority)
				{
					_baseMapZoomAuthority.adjustZoomBounds(visualization.plotManager.zoomBounds);
				}
			}
			
			// BACKWARDS COMPATIBILITY
			[Deprecated(replacement="zoomSliderHeight")] public function set sizeFactorOfMapControls(value:Number):void { zoomSliderHeight.value *= value; }
			[Deprecated(replacement="visualization.zoomToSelection")] public function get zoomToSelection():Function { return visualization.plotManager.zoomToSelection; }
			[Deprecated(replacement="zoomControlsLocation")] public function set maptoolsLocation(value:int):void { zoomControlsLocation.value = zoomControlsLocationsList[value]; }
		]]>
	</mx:Script>

	<mx:VBox id="mapControls"
			creationComplete="UIUtils.linkVisibility(this, visualization.enableZoomAndPan, event.target)"
			horizontalAlign="center"
			horizontalScrollPolicy="off" verticalScrollPolicy="off"
			initialize="UIUtils.pad(event, 4)"
			verticalGap="4"
			backgroundColor="white" backgroundAlpha="0.01">
		
		<mx:VBox id="panControls" horizontalAlign="center" verticalGap="1"
				 creationComplete="UIUtils.linkVisibility(this, showZoomControls, event.target)">
			<mx:Button id="north"
						label="N"
						fillAlphas="[1.0, 1.0, 1.0, 1.0]"
						width="17" height="17" buttonMode="true"
						click="handlePanButtonClick(0,1)"
						creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 1)"
						labelPlacement="left" fontSize="10" initialize="UIUtils.pad(event, 0)" cornerRadius="0" textAlign="center"
						/>
			
			<mx:HBox horizontalGap="1">
				<mx:Button id="west"
					    label="W"
						fillAlphas="[1.0, 1.0, 1.0, 1.0]"
						width="17" height="17" buttonMode="true"
						click="handlePanButtonClick(-1,0)"
						creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 1)"
						labelPlacement="left" fontSize="10" initialize="UIUtils.pad(event, 0)" cornerRadius="0" textAlign="center"/>
				<mx:Button id="zoomToExtentButton"
						   toolTip="Click this button to zoom to map's full extent"
						   icon="@Embed(source='/weave/resources/images/zoomToExtent.png')"
						   fillAlphas="[1,1]"
						   width="17" height="17" buttonMode="true"
						   cornerRadius="0"
						   creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 1)"
						   click="visualization.zoomToSelection()"/>
				<mx:Button id="east"
					    label="E"
						fillAlphas="[1.0, 1.0, 1.0, 1.0]"
						width="17" height="17" buttonMode="true"
						click="handlePanButtonClick(1,0)"
						creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 1)"
						labelPlacement="left" fontSize="10" initialize="UIUtils.pad(event, 0)" cornerRadius="0" textAlign="center">
				</mx:Button>
			</mx:HBox>
			
			<mx:Button id="south"
						label="S"
						fillAlphas="[1.0, 1.0, 1.0, 1.0]"
						width="17" height="17" buttonMode="true"
						click="handlePanButtonClick(0,-1)"
						creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 1)"
						labelPlacement="left" fontSize="10" initialize="UIUtils.pad(event, 0)" cornerRadius="0" textAlign="center"/>
		</mx:VBox>
		
		<mx:VBox creationComplete="UIUtils.linkVisibility(this, showZoomControls, event.target)"
				 verticalGap="2"
				 initialize="UIUtils.pad(event, 2)"
				 backgroundColor="white" backgroundAlpha="0.85" borderStyle="outset">
			<mx:Button id="zoomIn"
					icon="@Embed(source='/weave/resources/images/zoomPlus.png')"
					fillAlphas="[1.0, 1.0, 1.0, 1.0]"
					width="17" height="17" buttonMode="true"
					click="handleZoomInClick()"
				    creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 4)"
					cornerRadius="0" textAlign="center"/>
			
			<mx:VSlider id="zoomSlider"
						buttonMode="true"
						showDataTip="false"
						allowTrackClick="true"
						liveDragging="true"
						tickInterval="1"
						minimum="{zoomSliderMinimum}"
						maximum="{zoomSliderMaximum}"
						mouseDown="zoomSlider.setFocus()"
						change="handleZoomSliderChange(event);"/>
			
			<mx:Button id="zoomOut"
					icon="@Embed(source='/weave/resources/images/zoomMinus.png')"
					fillAlphas="[1.0, 1.0, 1.0, 1.0]"
					width="17" height="17" buttonMode="true"
					click="handleZoomOutClick()"
				    creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 4)"
					cornerRadius="0" textAlign="center"/>
		</mx:VBox>
		
		<mx:HBox id="mouseModeBox"
				 creationComplete="UIUtils.linkVisibility(this, showMouseModeControls, event.target)"
				 horizontalGap="1"
				 verticalAlign="top"
				 backgroundColor="white" backgroundAlpha="0.01"
				 alpha="1"> 
			<mx:Button id="panModeButton" 
			    creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 1)"
				icon="@Embed(source='/weave/resources/images/cursor_hand.png')"
				fillColors="{panModeButton.selected ? [0xFF8080, 0xFF8080] : [0x808080, 0x808080]}"
				fillAlphas="[1,1]"
				alpha="{panModeButton.selected ? 1 : 0.5}"
				width="17" height="17" buttonMode="true"
				toggle="true"
				toolTip="{lang('Pan mode')}"
				click="handleMouseModeChange(event)" cornerRadius="0"/>
			<mx:Button id="selectModeButton"
			    creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 1)"
				icon="@Embed(source='/weave/resources/images/selectMode.png')"
				fillColors="{selectModeButton.selected ? [0xFF8080, 0xFF8080] : [0x808080, 0x808080]}"
				fillAlphas="[1,1]"
				alpha="{selectModeButton.selected ? 1 : 0.5}"
				width="17" height="17" buttonMode="true"
				toggle="true"
				toolTip="{lang('Selection mode')}"
				click="handleMouseModeChange(event)" cornerRadius="0"/>
			<mx:Button id="selectModeAddButton"
			    creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 1)"
				icon="@Embed(source='/weave/resources/images/selectMode_add.png')"
				fillColors="{selectModeAddButton.selected ? [0xFF8080, 0xFF8080] : [0x808080, 0x808080]}"
				fillAlphas="[1,1]"
				alpha="{selectModeAddButton.selected ? 1 : 0.5}"
				width="17" height="17" buttonMode="true"
				toggle="true"
				toolTip="{lang('Selection mode (add)')}"
				click="handleMouseModeChange(event)" cornerRadius="0"
				visible="false" includeInLayout="false"
				/>
			<mx:Button id="selectModeSubtractButton"
			    creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 1)"
				icon="@Embed(source='/weave/resources/images/selectMode_subtract.png')"
				fillColors="{selectModeSubtractButton.selected ? [0xFF8080, 0xFF8080] : [0x808080, 0x808080]}"
				fillAlphas="[1,1]"
				alpha="{selectModeSubtractButton.selected ? 1 : 0.5}" 
				width="17" height="17" buttonMode="true"
				toggle="true"
				toolTip="{lang('Selection mode (subtract)')}"
				click="handleMouseModeChange(event)" cornerRadius="0"
				visible="false" includeInLayout="false"
				/>
			<mx:Button id="zoomModeButton"
			    creationComplete="UIUtils.drawInvisibleHalo(event.target as Button, 1)"
				icon="@Embed(source='/weave/resources/images/zoomMode.png')"
				fillColors="{zoomModeButton.selected ? [0xFF8080, 0xFF8080] : [0x808080, 0x808080]}"
				fillAlphas="[1,1]"
				alpha="{zoomModeButton.selected ? 1 : 0.5}"
				width="17" height="17" buttonMode="true"
				toggle="true"
				toolTip="{lang('Zoom mode')}"
				click="handleMouseModeChange(event)" cornerRadius="0"/>
		</mx:HBox>
	</mx:VBox>

	<editorFactory><mx:Component><ui:ControlPanel>
		<ui:creationComplete>
			layerControls.addChild(outerDocument.layersEditor);
			outerDocument.layersEditor.addChildAt(layerButtons, 0);
			outerDocument.layersEditor.removeChild(outerDocument.layersEditor.layerButtons);
			outerDocument.layersEditor.visible = true;
		</ui:creationComplete>
		<mx:VBox id="layerControls" label="{lang('Layers')}" width="100%" height="100%">
			<ui:Indent id="layerButtons" grouped="false" label="Add a layer:" translate="true" horizontalGap="4">
				<mx:Button label="{lang('Base Map')}" click="outerDocument.addWMSLayer();" toolTip="{lang('Add an image layer underneath the geometries')}"/>
				<mx:Button label="{lang('Geometry')}" click="outerDocument.addGeomLayer();" toolTip="{lang('Add a layer of polygons, lines, or points that can be colored according to the data')}"/>
				<mx:Button label="{lang('Labels')}" click="outerDocument.addLabelLayer();" toolTip="{lang('Add labels to the selected geometry layer')}"/>
				<mx:Button label="{lang('Bubbles')}" click="outerDocument.addBubbleLayer();" toolTip="{lang('Add bubbles to the selected geometry layer')}"/>
				<ui:MenuButton id="addLayerButton" label="{lang('Other...')}" toolTip="{lang('Add another type of layer')}" creationComplete="LayerListComponent.initAddLayerButton(addLayerButton, outerDocument.visualization)"/>
			</ui:Indent>
		</mx:VBox>
		<mx:VBox label="{lang('Advanced')}">
			<ui:Indent label="Projection" translate="true">
				<ui:CustomComboBox id="projComboBox"
								   dataProvider="{outerDocument._projComboBoxData}"
								   creationComplete="linkBindableProperty(outerDocument.projectionSRS, event.target, 'text');"
								   change="handleProjectionComboChange();"
								   selectedItem="{outerDocument.projComboBox_selectedItem}"
								   focusOut="projComboBox.selectedItem = outerDocument.projectionSRS.value; projValidLabel.text = '';"
								   editable="true"
								   width="120"
								   />
				<mx:Label id="projValidLabel" fontWeight="bold"/>
			</ui:Indent> 
			<mx:Button label="{lang('Zoom to full extent')}" click="outerDocument.visualization.zoomToSelection()"/>
			<mx:CheckBox id="probeColumnsCheckBox" label="{lang('Include tool attributes in probe tooltip')}"
						 creationComplete="linkBindableProperty(outerDocument.includeToolAttributesInProbe, event.target, 'selected')"/>
			<ui:CheckBoxWithNestedOptions id="enableZoomAndPanToggle" label="{lang('Enable panning and zooming')}"
						creationComplete="linkBindableProperty(outerDocument.visualization.enableZoomAndPan, event.target, 'selected')">
				<ui:CheckBoxWithNestedOptions id="showZoomControlsToggle" label="{lang('Show zoom slider &amp; buttons')}"
						creationComplete="linkBindableProperty(outerDocument.showZoomControls, event.target, 'selected')">
					<ui:Indent label="Zoom slider height" translate="true">
						<mx:NumericStepper minimum="40" maximum="200" stepSize="20" creationComplete="linkBindableProperty(outerDocument.zoomSliderHeight, event.target, 'value')"/>
					</ui:Indent>
				</ui:CheckBoxWithNestedOptions>
				<mx:CheckBox id="showMouseModeControlsToggle" label="{lang('Show mouse mode buttons')}"
							 creationComplete="linkBindableProperty(outerDocument.showMouseModeControls, event.target, 'selected')"/>
				<ui:Indent label="{lang('Zoom controls location')}" translate="true" grouped="false"
						   visible="{showMouseModeControlsToggle.selected || showZoomControlsToggle.selected}"
						   includeInLayout="{showMouseModeControlsToggle.selected || showZoomControlsToggle.selected}">
					<ui:CustomComboBox id="zoomControlsLocationCombo"
									   dataProvider="{outerDocument.zoomControlsLocationsList}"
									   change="outerDocument.zoomControlsLocation.value = zoomControlsLocationCombo.selectedItem as String;"
									   creationComplete="zoomControlsLocationCombo.labelFunction = lang;"/>
				</ui:Indent>
				<ui:Indent label="Zoom range" translate="true">
					<mx:NumericStepper minimum="-100" stepSize="1" creationComplete="linkBindableProperty(outerDocument.visualization.plotManager.minZoomLevel, event.target, 'value'); linkBindableProperty(outerDocument.visualization.plotManager.maxZoomLevel, event.target, 'maximum')"/>
					<mx:Label text="to"/>
					<mx:NumericStepper maximum="100" stepSize="1" creationComplete="linkBindableProperty(outerDocument.visualization.plotManager.maxZoomLevel, event.target, 'value'); linkBindableProperty(outerDocument.visualization.plotManager.minZoomLevel, event.target, 'minimum')"/>
				</ui:Indent>
				<ui:Indent label="Zoom factor" translate="true">
					<mx:NumericStepper maximum="10" minimum="1.25" stepSize=".25" creationComplete="linkBindableProperty(outerDocument.visualization.zoomFactor, event.target, 'value')"/>
					<ui:HelpComponent>
						Used for zoom +/- buttons, mouse wheel, and double-click.
					</ui:HelpComponent>
				</ui:Indent>
				<mx:HBox>
					<ui:CustomCheckBox label="{lang('Snap zoom level to base map')}" creationComplete="linkBindableProperty(outerDocument.zoomToBaseMap, event.target, 'selected')"/>
					<ui:HelpComponent>
						This option will make sure the zoom level matches the base map so the map image looks crisp as intended.
						Disabling this option allows more freedom in zooming while sacrificing image quality.
						
						This option has no effect when no base map is in use or when the selected projection does not match the projection of the base map.
					</ui:HelpComponent>
				</mx:HBox>
			</ui:CheckBoxWithNestedOptions>

			<mx:CheckBox label="{lang('Show map overview')}" id="overviewCheckBox"
						 creationComplete="linkBindableProperty(outerDocument.enableOverview, event.target, 'selected')"/>
			
			<mx:Spacer height="100%"/>
				
			<ui:Indent label="Coordinates at map center:" translate="true" grouped="false">
				<ui:Paragraph id="centerCoords" selectable="true" text="{outerDocument.centerCoords_text}"/>
			</ui:Indent>
		</mx:VBox>
		<mx:VBox label="{lang('Layer Visibility')}" verticalGap="10" id="visibleScaleRangesUI">
			<ui:Indent label="Current Zoom" translate="true" labelAlign="left" group="{visibleScaleRangesUI}">
				<mx:HSlider id="scaleRangeTabZoomSlider" 
							width="100%" 
							value="{outerDocument.scaleRangeTabZoomSlider_value}"
							tickInterval="1"
							change="outerDocument.handleZoomSliderChange(event);"
							minimum="{outerDocument.zoomSliderMinimum}"
							maximum="{outerDocument.zoomSliderMaximum}"
							liveDragging="true" />
			</ui:Indent>
			<mx:List id="visibleScaleRangesList"
								   width="100%" height="100%"
								   borderStyle="none"
								   paddingLeft="0">
				<mx:itemRenderer>
					<mx:Component>
						<ui:Indent labelAlign="left" group="{outerDocument.visibleScaleRangesUI}" creationComplete="handleCreationComplete()">
							<mx:Script>
								<![CDATA[
									import mx.events.SliderEvent;
									
									import weave.api.getCallbackCollection;
									import weave.api.ui.IPlotter;
									import weave.compiler.StandardLib;
									import weave.core.UIUtils;
									import weave.editors.managers.LayerListComponent;
									import weave.utils.ZoomUtils;
									import weave.visualization.layers.LayerSettings;
									import weave.visualization.layers.PlotManager;
									
									private var currentlyUpdatingLayerZoomRangeSlider:Boolean = false;
									
									private function handleCreationComplete():void
									{
										getCallbackCollection(pm.zoomBounds).addGroupedCallback(outerDocument, handleSettingsChange);
										getCallbackCollection(pm.minScreenSize).addGroupedCallback(outerDocument, handleSettingsChange);
										getCallbackCollection(pm.layerSettings).addGroupedCallback(outerDocument, handleSettingsChange);
									}
									
									private function get pm():PlotManager { return outerDocument.outerDocument.visualization.plotManager; }
									private function get settings():LayerSettings { return data as LayerSettings; }
									private function get plotter():IPlotter { return pm.plotters.getObject(pm.layerSettings.getName(data as LayerSettings)) as IPlotter; }
									
									override public function set data(value:Object):void
									{
										super.data = value as LayerSettings;
										handleSettingsChange();
									}
									
									private function handleSettingsChange():void
									{
										if (!settings)
											return;
										
										label = LayerListComponent.getLabelWithDescription(pm.plotters, plotter);
										var area:Number = pm.fullDataBounds.getArea();
										if (!isNaN(area))
										{
											var minZoomLevel:Number = ZoomUtils.getZoomLevelFromScale(
												pm.fullDataBounds, pm.minScreenSize.value, settings.minVisibleScale.value
											);
											
											var maxZoomLevel:Number = ZoomUtils.getZoomLevelFromScale(
												pm.fullDataBounds, pm.minScreenSize.value, settings.maxVisibleScale.value
											);
											
											currentlyUpdatingLayerZoomRangeSlider = true;
											var newValues:Array = [minZoomLevel, maxZoomLevel];
											if (StandardLib.compare(layerZoomRangeSlider.values, newValues) == 0)
												layerZoomRangeSlider.values = [NaN, NaN];
											layerZoomRangeSlider.values = newValues;
											currentlyUpdatingLayerZoomRangeSlider = false;
										}
									}
									
									private function handleScaleSliderChange(event:SliderEvent):void
									{
										if (data && !currentlyUpdatingLayerZoomRangeSlider && UIUtils.hasFocus(layerZoomRangeSlider))
										{
											var minScreenSize:Number = pm.minScreenSize.value;
											var minVisibleZoomLevel:Number = layerZoomRangeSlider.values[0];
											var maxVisibleZoomLevel:Number = layerZoomRangeSlider.values[1];
											
											data.minVisibleScale.value = ZoomUtils.getScaleFromZoomLevel(
												pm.fullDataBounds, minScreenSize, minVisibleZoomLevel
											);
											
											data.maxVisibleScale.value = ZoomUtils.getScaleFromZoomLevel(
												pm.fullDataBounds, minScreenSize, maxVisibleZoomLevel
											);
										}
									}
								]]>
							</mx:Script>
							
							<mx:HSlider id="layerZoomRangeSlider"
										liveDragging="true"
										thumbCount="2"
										tickInterval="1"
										snapInterval="{outerDocument.outerDocument.layerZoomRangeSlider_snapInterval}"
										showTrackHighlight="true"
										minimum="{outerDocument.outerDocument.zoomSliderMinimum}"
										maximum="{outerDocument.outerDocument.zoomSliderMaximum}"
										change="handleScaleSliderChange(event)"
										mouseDown="event.target.setFocus(); event.stopPropagation()"
										width="100%"/>
						</ui:Indent>
					</mx:Component>			
				</mx:itemRenderer>
			</mx:List>
		</mx:VBox>
		<mx:Script>
			<![CDATA[
				import weave.api.linkBindableProperty;
				import weave.editors.managers.LayerListComponent;
				import weave.core.UIUtils;
				import weave.ui.VariableListController;
				import weave.api.newDisposableChild;
				import weave.visualization.layers.LayerSettings;
				
				private const visibleScaleController:VariableListController = newDisposableChild(this, VariableListController);
				
				override protected function childrenCreated():void
				{
					super.childrenCreated();
					
					visibleScaleController.view = visibleScaleRangesList;
					visibleScaleController.hashMap = outerDocument.visualization.plotManager.layerSettings;
					WeaveAPI.SessionManager.getCallbackCollection(outerDocument.visualization.plotManager.plotters).addGroupedCallback(this, visibleScaleRangesList.invalidateList);
				}
				
				private function handleProjectionComboChange():void
				{
					if (UIUtils.hasFocus(projComboBox))
					{
						// clear all layer visibility settings because they are no longer valid in the new projection
						outerDocument.visualization.plotManager.layerSettings.delayCallbacks();
						for each (var settings:LayerSettings in outerDocument.visualization.plotManager.layerSettings.getObjects())
						{
							settings.minVisibleScale.value = 0;
							settings.maxVisibleScale.value = Infinity;
						}
						outerDocument.visualization.plotManager.layerSettings.resumeCallbacks();
					}
					if (outerDocument.projectionVerifier(projComboBox.text))
					{
						projValidLabel.text = lang('Valid');
						projComboBox.errorString = '';
					}
					else
					{
						projValidLabel.text = lang('Invalid');
						projComboBox.errorString = lang('Unknown projection');
					}
				}

			]]>
		</mx:Script>
	</ui:ControlPanel></mx:Component></editorFactory>
	
	<!-- read by ControlPanel -->
	<mx:Number id="layerZoomRangeSlider_snapInterval">0.25</mx:Number>
	<mx:Number id="scaleRangeTabZoomSlider_value"/>
	<mx:String id="centerCoords_text"/>
	<mx:String id="projComboBox_selectedItem"/>
	
	<!-- read by both ControlPanel and MapTool -->
	<mx:Number id="zoomSliderMinimum"/>
	<mx:Number id="zoomSliderMaximum"/>
</SimpleVisTool>
